{
  "version": 3,
  "sources": ["../@splidejs/splide/dist/js/splide.esm.js", "dep:@splidejs_splide"],
  "sourcesContent": ["/*!\n * Splide.js\n * Version  : 2.4.20\n * License  : MIT\n * Copyright: 2020 Naotoshi Fujita\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Splide\"] = factory();\n\telse\n\t\troot[\"Splide\"] = factory();\n})(self, function() {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 311:\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => /* binding */ module_Splide\n});\n\n// NAMESPACE OBJECT: ./src/js/constants/states.js\nvar states_namespaceObject = {};\n__webpack_require__.r(states_namespaceObject);\n__webpack_require__.d(states_namespaceObject, {\n  \"CREATED\": () => CREATED,\n  \"DESTROYED\": () => DESTROYED,\n  \"IDLE\": () => IDLE,\n  \"MOUNTED\": () => MOUNTED,\n  \"MOVING\": () => MOVING\n});\n\n;// CONCATENATED MODULE: ./src/js/core/event.js\n/**\r\n * The function for providing an Event object simply managing events.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * The function for providing an Event object simply managing events.\r\n */\n/* harmony default export */ const core_event = (function () {\n  /**\r\n   * Store all event data.\r\n   *\r\n   * @type {Array}\r\n   */\n  var data = [];\n  var Event = {\n    /**\r\n     * Subscribe the given event(s).\r\n     *\r\n     * @param {string}   events  - An event name. Use space to separate multiple events.\r\n     *                             Also, namespace is accepted by dot, such as 'resize.{namespace}'.\r\n     * @param {function} handler - A callback function.\r\n     * @param {Element}  elm     - Optional. Native event will be listened to when this arg is provided.\r\n     * @param {Object}   options - Optional. Options for addEventListener.\r\n     */\n    on: function on(events, handler, elm, options) {\n      if (elm === void 0) {\n        elm = null;\n      }\n\n      if (options === void 0) {\n        options = {};\n      }\n\n      events.split(' ').forEach(function (event) {\n        if (elm) {\n          elm.addEventListener(event, handler, options);\n        }\n\n        data.push({\n          event: event,\n          handler: handler,\n          elm: elm,\n          options: options\n        });\n      });\n    },\n\n    /**\r\n     * Unsubscribe the given event(s).\r\n     *\r\n     * @param {string}  events - A event name or names split by space.\r\n     * @param {Element} elm    - Optional. removeEventListener() will be called when this arg is provided.\r\n     */\n    off: function off(events, elm) {\n      if (elm === void 0) {\n        elm = null;\n      }\n\n      events.split(' ').forEach(function (event) {\n        data = data.filter(function (item) {\n          if (item && item.event === event && item.elm === elm) {\n            unsubscribe(item);\n            return false;\n          }\n\n          return true;\n        });\n      });\n    },\n\n    /**\r\n     * Emit an event.\r\n     * This method is only for custom events.\r\n     *\r\n     * @param {string}  event - An event name.\r\n     * @param {*}       args  - Any number of arguments passed to handlers.\r\n     */\n    emit: function emit(event) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      data.forEach(function (item) {\n        if (!item.elm && item.event.split('.')[0] === event) {\n          item.handler.apply(item, args);\n        }\n      });\n    },\n\n    /**\r\n     * Clear event data.\r\n     */\n    destroy: function destroy() {\n      data.forEach(unsubscribe);\n      data = [];\n    }\n  };\n  /**\r\n   * Remove the registered event listener.\r\n   *\r\n   * @param {Object} item - An object containing event data.\r\n   */\n\n  function unsubscribe(item) {\n    if (item.elm) {\n      item.elm.removeEventListener(item.event, item.handler, item.options);\n    }\n  }\n\n  return Event;\n});\n;// CONCATENATED MODULE: ./src/js/core/state.js\n/**\r\n * The function providing a super simple state system.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * The function providing a super simple state system.\r\n *\r\n * @param {string|number} initialState - Provide the initial state value.\r\n */\n/* harmony default export */ const state = (function (initialState) {\n  /**\r\n   * Store the current state.\r\n   *\r\n   * @type {string|number}\r\n   */\n  var curr = initialState;\n  return {\n    /**\r\n     * Change state.\r\n     *\r\n     * @param {string|number} state - A new state.\r\n     */\n    set: function set(state) {\n      curr = state;\n    },\n\n    /**\r\n     * Verify if the current state is given one or not.\r\n     *\r\n     * @param {string|number} state - A state name to be verified.\r\n     *\r\n     * @return {boolean} - True if the current state is the given one.\r\n     */\n    is: function is(state) {\n      return state === curr;\n    }\n  };\n});\n;// CONCATENATED MODULE: ./src/js/utils/object.js\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n/**\r\n * Some utility functions related with Object, supporting IE.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\nvar keys = Object.keys;\n/**\r\n * Iterate an object like Array.forEach.\r\n * IE doesn't support forEach of HTMLCollection.\r\n *\r\n * @param {Object}    obj       - An object.\r\n * @param {function}  callback  - A function handling each value. Arguments are value, property and index.\r\n */\n\nfunction each(obj, callback) {\n  keys(obj).some(function (key, index) {\n    return callback(obj[key], key, index);\n  });\n}\n/**\r\n * Return values of the given object as an array.\r\n * IE doesn't support Object.values.\r\n *\r\n * @param {Object} obj - An object.\r\n *\r\n * @return {Array} - An array containing all values of the given object.\r\n */\n\nfunction values(obj) {\n  return keys(obj).map(function (key) {\n    return obj[key];\n  });\n}\n/**\r\n * Check if the given subject is object or not.\r\n *\r\n * @param {*} subject - A subject to be verified.\r\n *\r\n * @return {boolean} - True if object, false otherwise.\r\n */\n\nfunction isObject(subject) {\n  return typeof subject === 'object';\n}\n/**\r\n * Merge two objects deeply.\r\n *\r\n * @param {Object} to   - An object where \"from\" is merged.\r\n * @param {Object} from - An object merged to \"to\".\r\n *\r\n * @return {Object} - A merged object.\r\n */\n\nfunction merge(_ref, from) {\n  var to = _extends({}, _ref);\n\n  each(from, function (value, key) {\n    if (isObject(value)) {\n      if (!isObject(to[key])) {\n        to[key] = {};\n      }\n\n      to[key] = merge(to[key], value);\n    } else {\n      to[key] = value;\n    }\n  });\n  return to;\n}\n/**\r\n * Assign all properties \"from\" to \"to\" object.\r\n *\r\n * @param {Object} to   - An object where properties are assigned.\r\n * @param {Object} from - An object whose properties are assigned to \"to\".\r\n *\r\n * @return {Object} - An assigned object.\r\n */\n\nfunction object_assign(to, from) {\n  keys(from).forEach(function (key) {\n    if (!to[key]) {\n      Object.defineProperty(to, key, Object.getOwnPropertyDescriptor(from, key));\n    }\n  });\n  return to;\n}\n;// CONCATENATED MODULE: ./src/js/utils/utils.js\n/**\r\n * A package of some miscellaneous utility functions.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Convert the given value to array.\r\n *\r\n * @param {*} value - Any value.\r\n *\r\n * @return {*[]} - Array containing the given value.\r\n */\n\nfunction toArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n/**\r\n * Check if the given value is between min and max.\r\n * Min will be returned when the value is less than min or max will do when greater than max.\r\n *\r\n * @param {number} value - A number to be checked.\r\n * @param {number} m1    - Minimum or maximum number.\r\n * @param {number} m2    - Maximum or minimum number.\r\n *\r\n * @return {number} - A value itself, min or max.\r\n */\n\nfunction between(value, m1, m2) {\n  return Math.min(Math.max(value, m1 > m2 ? m2 : m1), m1 > m2 ? m1 : m2);\n}\n/**\r\n * The sprintf method with minimum functionality.\r\n *\r\n * @param {string}       format       - The string format.\r\n * @param {string|Array} replacements - Replacements accepting multiple arguments.\r\n *\r\n * @returns {string} - Converted string.\r\n */\n\nfunction sprintf(format, replacements) {\n  var i = 0;\n  return format.replace(/%s/g, function () {\n    return toArray(replacements)[i++];\n  });\n}\n/**\r\n * Append px unit to the given subject if necessary.\r\n *\r\n * @param {number|string} value - A value that may not include an unit.\r\n *\r\n * @return {string} - If the value is string, return itself.\r\n *                    If number, do value + \"px\". An empty string, otherwise.\r\n */\n\nfunction unit(value) {\n  var type = typeof value;\n\n  if (type === 'number' && value > 0) {\n    return parseFloat(value) + 'px';\n  }\n\n  return type === 'string' ? value : '';\n}\n/**\r\n * Pad start with 0.\r\n *\r\n * @param {number} number - A number to be filled with 0.\r\n *\r\n * @return {string|number} - Padded number.\r\n */\n\nfunction pad(number) {\n  return number < 10 ? '0' + number : number;\n}\n/**\r\n * Convert the given value to pixel.\r\n *\r\n * @param {Element}       root  - Root element where a dummy div is appended.\r\n * @param {string|number} value - CSS value to be converted, such as 10rem.\r\n *\r\n * @return {number} - Pixel.\r\n */\n\nfunction toPixel(root, value) {\n  if (typeof value === 'string') {\n    var div = create('div', {});\n    applyStyle(div, {\n      position: 'absolute',\n      width: value\n    });\n    append(root, div);\n    value = div.clientWidth;\n    dom_remove(div);\n  }\n\n  return +value || 0;\n}\n;// CONCATENATED MODULE: ./src/js/utils/dom.js\n/**\r\n * Some utility functions related with DOM.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * Find the first element matching the given selector.\r\n * Be aware that all selectors after a space are ignored.\r\n *\r\n * @param {Element|Node}  elm       - An ancestor element.\r\n * @param {string}        selector  - DOMString.\r\n *\r\n * @return {Element|null} - A found element or null.\r\n */\n\nfunction find(elm, selector) {\n  return elm ? elm.querySelector(selector.split(' ')[0]) : null;\n}\n/**\r\n * Find a first child having the given tag or class name.\r\n *\r\n * @param {Element} parent         - A parent element.\r\n * @param {string}  tagOrClassName - A tag or class name.\r\n *\r\n * @return {Element|undefined} - A found element on success or undefined on failure.\r\n */\n\nfunction child(parent, tagOrClassName) {\n  return children(parent, tagOrClassName)[0];\n}\n/**\r\n * Return chile elements that matches the provided tag or class name.\r\n *\r\n * @param {Element} parent         - A parent element.\r\n * @param {string}  tagOrClassName - A tag or class name.\r\n *\r\n * @return {Element[]} - Found elements.\r\n */\n\nfunction children(parent, tagOrClassName) {\n  if (parent) {\n    return values(parent.children).filter(function (child) {\n      return hasClass(child, tagOrClassName.split(' ')[0]) || child.tagName === tagOrClassName;\n    });\n  }\n\n  return [];\n}\n/**\r\n * Create an element with some optional attributes.\r\n *\r\n * @param {string} tag   - A tag name.\r\n * @param {Object} attrs - An object any attribute pairs of name and value.\r\n *\r\n * @return {Element} - A created element.\r\n */\n\nfunction create(tag, attrs) {\n  var elm = document.createElement(tag);\n  each(attrs, function (value, key) {\n    return setAttribute(elm, key, value);\n  });\n  return elm;\n}\n/**\r\n * Convert HTML string to DOM node.\r\n *\r\n * @param {string} html - HTML string.\r\n *\r\n * @return {Node} - A created node.\r\n */\n\nfunction domify(html) {\n  var div = create('div', {});\n  div.innerHTML = html;\n  return div.firstChild;\n}\n/**\r\n * Remove a given element from a DOM tree.\r\n *\r\n * @param {Element|Element[]} elms - Element(s) to be removed.\r\n */\n\nfunction dom_remove(elms) {\n  toArray(elms).forEach(function (elm) {\n    if (elm) {\n      var parent = elm.parentElement;\n      parent && parent.removeChild(elm);\n    }\n  });\n}\n/**\r\n * Append a child to a given element.\r\n *\r\n * @param {Element} parent - A parent element.\r\n * @param {Element} child  - An element to be appended.\r\n */\n\nfunction append(parent, child) {\n  if (parent) {\n    parent.appendChild(child);\n  }\n}\n/**\r\n * Insert an element before the reference element.\r\n *\r\n * @param {Element|Node} ref - A reference element.\r\n * @param {Element}      elm - An element to be inserted.\r\n */\n\nfunction before(elm, ref) {\n  if (elm && ref) {\n    var parent = ref.parentElement;\n    parent && parent.insertBefore(elm, ref);\n  }\n}\n/**\r\n * Apply styles to the given element.\r\n *\r\n * @param {Element} elm     - An element where styles are applied.\r\n * @param {Object}  styles  - Object containing styles.\r\n */\n\nfunction applyStyle(elm, styles) {\n  if (elm) {\n    each(styles, function (value, prop) {\n      if (value !== null) {\n        elm.style[prop] = value;\n      }\n    });\n  }\n}\n/**\r\n * Add or remove classes to/from the element.\r\n * This function is for internal usage.\r\n *\r\n * @param {Element}         elm     - An element where classes are added.\r\n * @param {string|string[]} classes - Class names being added.\r\n * @param {boolean}         remove  - Whether to remove or add classes.\r\n */\n\nfunction addOrRemoveClasses(elm, classes, remove) {\n  if (elm) {\n    toArray(classes).forEach(function (name) {\n      if (name) {\n        elm.classList[remove ? 'remove' : 'add'](name);\n      }\n    });\n  }\n}\n/**\r\n * Add classes to the element.\r\n *\r\n * @param {Element}          elm     - An element where classes are added.\r\n * @param {string|string[]}  classes - Class names being added.\r\n */\n\n\nfunction addClass(elm, classes) {\n  addOrRemoveClasses(elm, classes, false);\n}\n/**\r\n * Remove a class from the element.\r\n *\r\n * @param {Element}         elm     - An element where classes are removed.\r\n * @param {string|string[]} classes - A class name being removed.\r\n */\n\nfunction removeClass(elm, classes) {\n  addOrRemoveClasses(elm, classes, true);\n}\n/**\r\n * Verify if the provided element has the class or not.\r\n *\r\n * @param {Element} elm       - An element.\r\n * @param {string}  className - A class name.\r\n *\r\n * @return {boolean} - True if the element has the class or false if not.\r\n */\n\nfunction hasClass(elm, className) {\n  return !!elm && elm.classList.contains(className);\n}\n/**\r\n * Set attribute to the given element.\r\n *\r\n * @param {Element}                 elm   - An element where an attribute is assigned.\r\n * @param {string}                  name  - Attribute name.\r\n * @param {string|number|boolean}   value - Attribute value.\r\n */\n\nfunction setAttribute(elm, name, value) {\n  if (elm) {\n    elm.setAttribute(name, value);\n  }\n}\n/**\r\n * Get attribute from the given element.\r\n *\r\n * @param {Element} elm  - An element where an attribute is assigned.\r\n * @param {string}  name - Attribute name.\r\n *\r\n * @return {string} - The value of the given attribute if available. An empty string if not.\r\n */\n\nfunction getAttribute(elm, name) {\n  return elm ? elm.getAttribute(name) : '';\n}\n/**\r\n * Remove attribute from the given element.\r\n *\r\n * @param {Element|Element[]} elms  - An element where an attribute is removed.\r\n * @param {string|string[]}      names - Attribute name.\r\n */\n\nfunction removeAttribute(elms, names) {\n  toArray(names).forEach(function (name) {\n    toArray(elms).forEach(function (elm) {\n      return elm && elm.removeAttribute(name);\n    });\n  });\n}\n/**\r\n * Return the Rect object of the provided object.\r\n *\r\n * @param {Element} elm - An element.\r\n *\r\n * @return {ClientRect|DOMRect} - A rect object.\r\n */\n\nfunction getRect(elm) {\n  return elm.getBoundingClientRect();\n}\n/**\r\n * Trigger the given callback after all images contained by the element are loaded.\r\n *\r\n * @param {Element}  elm      - Element that may contain images.\r\n * @param {Function} callback - Callback function fired right after all images are loaded.\r\n */\n\nfunction loaded(elm, callback) {\n  var images = elm.querySelectorAll('img');\n  var length = images.length;\n\n  if (length) {\n    var count = 0;\n    each(images, function (img) {\n      img.onload = img.onerror = function () {\n        if (++count === length) {\n          callback();\n        }\n      };\n    });\n  } else {\n    // Trigger the callback immediately if there is no image.\n    callback();\n  }\n}\n;// CONCATENATED MODULE: ./src/js/constants/types.js\n/**\r\n * Export slider types.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Normal slider.\r\n *\r\n * @type {string}\r\n */\nvar SLIDE = 'slide';\n/**\r\n * Loop after the last slide and before the first one.\r\n *\r\n * @type {string}\r\n */\n\nvar LOOP = 'loop';\n/**\r\n * The track doesn't move.\r\n *\r\n * @type {string}\r\n */\n\nvar FADE = 'fade';\n;// CONCATENATED MODULE: ./src/js/transitions/slide/index.js\n/**\r\n * The component for general slide effect transition.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * The component for general slide effect transition.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const slide = (function (Splide, Components) {\n  /**\r\n   * Hold the list element.\r\n   *\r\n   * @type {Element}\r\n   */\n  var list;\n  /**\r\n   * Hold the onEnd callback function.\r\n   *\r\n   * @type {function}\r\n   */\n\n  var endCallback;\n  return {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      list = Components.Elements.list;\n      Splide.on('transitionend', function (e) {\n        if (e.target === list && endCallback) {\n          endCallback();\n        }\n      }, list);\n    },\n\n    /**\r\n     * Start transition.\r\n     *\r\n     * @param {number}   destIndex - Destination slide index that might be clone's.\r\n     * @param {number}   newIndex  - New index.\r\n     * @param {number}   prevIndex - Previous index.\r\n     * @param {Object}   coord     - Destination coordinates.\r\n     * @param {function} done      - Callback function must be invoked when transition is completed.\r\n     */\n    start: function start(destIndex, newIndex, prevIndex, coord, done) {\n      var options = Splide.options;\n      var edgeIndex = Components.Controller.edgeIndex;\n      var speed = options.speed;\n      endCallback = done;\n\n      if (Splide.is(SLIDE)) {\n        if (prevIndex === 0 && newIndex >= edgeIndex || prevIndex >= edgeIndex && newIndex === 0) {\n          speed = options.rewindSpeed || speed;\n        }\n      }\n\n      applyStyle(list, {\n        transition: \"transform \" + speed + \"ms \" + options.easing,\n        transform: \"translate(\" + coord.x + \"px,\" + coord.y + \"px)\"\n      });\n    }\n  };\n});\n;// CONCATENATED MODULE: ./src/js/transitions/fade/index.js\n/**\r\n * The component for fade transition.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * The component for fade transition.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const fade = (function (Splide, Components) {\n  var Fade = {\n    /**\r\n     * Called when the component is mounted.\r\n     * Apply transition style to the first slide.\r\n     */\n    mount: function mount() {\n      apply(Splide.index);\n    },\n\n    /**\r\n     * Start transition.\r\n     *\r\n     * @param {number}    destIndex - Destination slide index that might be clone's.\r\n     * @param {number}    newIndex  - New index.\r\n     * @param {number}    prevIndex - Previous index.\r\n     * @param {Object}    coord     - Destination coordinates.\r\n     * @param {function}  done      - Callback function must be invoked when transition is completed.\r\n     */\n    start: function start(destIndex, newIndex, prevIndex, coord, done) {\n      var track = Components.Elements.track;\n      applyStyle(track, {\n        height: unit(track.clientHeight)\n      });\n      apply(newIndex);\n      setTimeout(function () {\n        done();\n        applyStyle(track, {\n          height: ''\n        });\n      });\n    }\n  };\n  /**\r\n   * Apply transition style to the slide specified by the given index.\r\n   *\r\n   * @param {number} index - A slide index.\r\n   */\n\n  function apply(index) {\n    var options = Splide.options;\n    applyStyle(Components.Elements.slides[index], {\n      transition: \"opacity \" + options.speed + \"ms \" + options.easing\n    });\n  }\n\n  return Fade;\n});\n;// CONCATENATED MODULE: ./src/js/transitions/index.js\n/**\r\n * Export transition components.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n;// CONCATENATED MODULE: ./src/js/core/composer.js\n/**\r\n * Provide a function for composing components.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * Compose components.\r\n *\r\n * @param {Splide}   Splide     - Splide instance.\r\n * @param {Object}   Components - Additional components.\r\n * @param {function} Transition - Change component for transition.\r\n *\r\n * @return {Object} - An object containing all components.\r\n */\n\nfunction compose(Splide, Components, Transition) {\n  var components = {};\n  each(Components, function (Component, name) {\n    components[name] = Component(Splide, components, name.toLowerCase());\n  });\n\n  if (!Transition) {\n    Transition = Splide.is(FADE) ? fade : slide;\n  }\n\n  components.Transition = Transition(Splide, components);\n  return components;\n}\n;// CONCATENATED MODULE: ./src/js/utils/error.js\n/**\r\n * Utility functions for outputting logs.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Prefix of an error massage.\r\n *\r\n * @type {string}\r\n */\nvar MESSAGE_PREFIX = '[SPLIDE]';\n/**\r\n * Display an error message on the browser console.\r\n *\r\n * @param {string} message - An error message.\r\n */\n\nfunction error(message) {\n  console.error(MESSAGE_PREFIX + \" \" + message);\n}\n/**\r\n * Check existence of the given object and throw an error if it doesn't.\r\n *\r\n * @throws {Error}\r\n *\r\n * @param {*}      subject - A subject to be confirmed.\r\n * @param {string} message - An error message.\r\n */\n\nfunction exist(subject, message) {\n  if (!subject) {\n    throw new Error(message);\n  }\n}\n;// CONCATENATED MODULE: ./src/js/constants/classes.js\n/**\r\n * Export class names.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * A root class name.\r\n *\r\n * @type {string}\r\n */\nvar ROOT = 'splide';\n/**\r\n * The definition table of all classes for elements.\r\n * They might be modified by options.\r\n *\r\n * @type {Object}\r\n */\n\nvar ELEMENT_CLASSES = {\n  root: ROOT,\n  slider: ROOT + \"__slider\",\n  track: ROOT + \"__track\",\n  list: ROOT + \"__list\",\n  slide: ROOT + \"__slide\",\n  container: ROOT + \"__slide__container\",\n  arrows: ROOT + \"__arrows\",\n  arrow: ROOT + \"__arrow\",\n  prev: ROOT + \"__arrow--prev\",\n  next: ROOT + \"__arrow--next\",\n  pagination: ROOT + \"__pagination\",\n  page: ROOT + \"__pagination__page\",\n  clone: ROOT + \"__slide--clone\",\n  progress: ROOT + \"__progress\",\n  bar: ROOT + \"__progress__bar\",\n  autoplay: ROOT + \"__autoplay\",\n  play: ROOT + \"__play\",\n  pause: ROOT + \"__pause\",\n  spinner: ROOT + \"__spinner\",\n  sr: ROOT + \"__sr\"\n};\n/**\r\n * Definitions of status classes.\r\n *\r\n * @type {Object}\r\n */\n\nvar STATUS_CLASSES = {\n  active: 'is-active',\n  visible: 'is-visible',\n  loading: 'is-loading'\n};\n;// CONCATENATED MODULE: ./src/js/constants/i18n.js\n/**\r\n * Export i18n texts as object.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Texts for i18n.\r\n *\r\n * @type {Object}\r\n */\nvar I18N = {\n  prev: 'Previous slide',\n  next: 'Next slide',\n  first: 'Go to first slide',\n  last: 'Go to last slide',\n  slideX: 'Go to slide %s',\n  pageX: 'Go to page %s',\n  play: 'Start autoplay',\n  pause: 'Pause autoplay'\n};\n;// CONCATENATED MODULE: ./src/js/constants/defaults.js\n/**\r\n * Export default options.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\nvar DEFAULTS = {\n  /**\r\n   * Determine a slider type.\r\n   * - 'slide': Regular slider.\r\n   * - 'loop' : Carousel slider.\r\n   * - 'fade' : Change slides with fade transition. perPage, drag options are ignored.\r\n   *\r\n   * @type {string}\r\n   */\n  type: 'slide',\n\n  /**\r\n   * Whether to rewind a slider before the first slide or after the last one.\r\n   * In \"loop\" mode, this option is ignored.\r\n   *\r\n   * @type {boolean}\r\n   */\n  rewind: false,\n\n  /**\r\n   * Transition speed in milliseconds.\r\n   *\r\n   * @type {number}\r\n   */\n  speed: 400,\n\n  /**\r\n   * Transition speed on rewind in milliseconds.\r\n   *\r\n   * @type {number}\r\n   */\n  rewindSpeed: 0,\n\n  /**\r\n   * Whether to prevent any actions while a slider is transitioning.\r\n   * If false, navigation, drag and swipe work while the slider is running.\r\n   * Even so, it will be forced to wait for transition in some cases in the loop mode to shift a slider.\r\n   *\r\n   * @type {boolean}\r\n   */\n  waitForTransition: true,\n\n  /**\r\n   * Define slider max width.\r\n   *\r\n   * @type {number}\r\n   */\n  width: 0,\n\n  /**\r\n   * Define slider height.\r\n   *\r\n   * @type {number}\r\n   */\n  height: 0,\n\n  /**\r\n   * Fix width of slides. CSS format is allowed such as 10em, 80% or 80vw.\r\n   * perPage number will be ignored when this option is falsy.\r\n   *\r\n   * @type {number|string}\r\n   */\n  fixedWidth: 0,\n\n  /**\r\n   * Fix height of slides. CSS format is allowed such as 10em, 80vh but % unit is not accepted.\r\n   * heightRatio option will be ignored when this option is falsy.\r\n   *\r\n   * @type {number|string}\r\n   */\n  fixedHeight: 0,\n\n  /**\r\n   * Determine height of slides by ratio to a slider width.\r\n   * This will be ignored when the fixedHeight is provided.\r\n   *\r\n   * @type {number}\r\n   */\n  heightRatio: 0,\n\n  /**\r\n   * If true, slide width will be determined by the element width itself.\r\n   * - perPage/perMove should be 1.\r\n   *\r\n   * @type {boolean}\r\n   */\n  autoWidth: false,\n\n  /**\r\n   * If true, slide height will be determined by the element width itself.\r\n   * - perPage/perMove should be 1.\r\n   *\r\n   * @type {boolean}\r\n   */\n  autoHeight: false,\n\n  /**\r\n   * Determine how many slides should be displayed per page.\r\n   *\r\n   * @type {number}\r\n   */\n  perPage: 1,\n\n  /**\r\n   * Determine how many slides should be moved when a slider goes to next or perv.\r\n   *\r\n   * @type {number}\r\n   */\n  perMove: 0,\n\n  /**\r\n   * Determine manually how many clones should be generated on the left and right side.\r\n   * The total number of clones will be twice of this number.\r\n   *\r\n   * @type {number}\r\n   */\n  clones: 0,\n\n  /**\r\n   * Start index.\r\n   *\r\n   * @type {number}\r\n   */\n  start: 0,\n\n  /**\r\n   * Determine which slide should be focused if there are multiple slides in a page.\r\n   * A string \"center\" is acceptable for centering slides.\r\n   *\r\n   * @type {boolean|number|string}\r\n   */\n  focus: false,\n\n  /**\r\n   * Gap between slides. CSS format is allowed such as 1em.\r\n   *\r\n   * @type {number|string}\r\n   */\n  gap: 0,\n\n  /**\r\n   * Set padding-left/right in horizontal mode or padding-top/bottom in vertical one.\r\n   * Give a single value to set a same size for both sides or\r\n   * do an object for different sizes.\r\n   * Also, CSS format is allowed such as 1em.\r\n   *\r\n   * @example\r\n   * - 10: Number\r\n   * - '1em': CSS format.\r\n   * - { left: 0, right: 20 }: Object for different sizes in horizontal mode.\r\n   * - { top: 0, bottom: 20 }: Object for different sizes in vertical mode.\r\n   *\r\n   * @type {number|string|Object}\r\n   */\n  padding: 0,\n\n  /**\r\n   * Whether to append arrows.\r\n   *\r\n   * @type {boolean}\r\n   */\n  arrows: true,\n\n  /**\r\n   * Change the arrow SVG path like 'm7.61 0.807-2.12...'.\r\n   *\r\n   * @type {string}\r\n   */\n  arrowPath: '',\n\n  /**\r\n   * Whether to append pagination(indicator dots) or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n  pagination: true,\n\n  /**\r\n   * Activate autoplay.\r\n   *\r\n   * @type {boolean}\r\n   */\n  autoplay: false,\n\n  /**\r\n   * Autoplay interval in milliseconds.\r\n   *\r\n   * @type {number}\r\n   */\n  interval: 5000,\n\n  /**\r\n   * Whether to stop autoplay when a slider is hovered.\r\n   *\r\n   * @type {boolean}\r\n   */\n  pauseOnHover: true,\n\n  /**\r\n   * Whether to stop autoplay when a slider elements are focused.\r\n   * True is recommended for accessibility.\r\n   *\r\n   * @type {boolean}\r\n   */\n  pauseOnFocus: true,\n\n  /**\r\n   * Whether to reset progress of the autoplay timer when resumed.\r\n   *\r\n   * @type {boolean}\r\n   */\n  resetProgress: true,\n\n  /**\r\n   * Loading images lazily.\r\n   * Image src must be provided by a data-splide-lazy attribute.\r\n   *\r\n   * - false: Do nothing.\r\n   * - 'nearby': Only images around an active slide will be loaded.\r\n   * - 'sequential': All images will be sequentially loaded.\r\n   *\r\n   * @type {boolean|string}\r\n   */\n  lazyLoad: false,\n\n  /**\r\n   * This option works only when a lazyLoad option is \"nearby\".\r\n   * Determine how many pages(not slides) around an active slide should be loaded beforehand.\r\n   *\r\n   * @type {number}\r\n   */\n  preloadPages: 1,\n\n  /**\r\n   * Easing for CSS transition. For example, linear, ease or cubic-bezier().\r\n   *\r\n   * @type {string}\r\n   */\n  easing: 'cubic-bezier(.42,.65,.27,.99)',\n\n  /**\r\n   * Whether to enable keyboard shortcuts\r\n   * - true or 'global': Listen to keydown event of the document.\r\n   * - 'focused': Listen to the keydown event of the slider root element. tabindex=\"0\" will be added to the element.\r\n   * - false: Disable keyboard shortcuts.\r\n   *\r\n   * @type {boolean|string}\r\n   */\n  keyboard: 'global',\n\n  /**\r\n   * Whether to allow mouse drag and touch swipe.\r\n   *\r\n   * @type {boolean}\r\n   */\n  drag: true,\n\n  /**\r\n   * The angle threshold for drag.\r\n   * The slider starts moving only when the drag angle is less than this threshold.\r\n   *\r\n   * @type {number}\r\n   */\n  dragAngleThreshold: 30,\n\n  /**\r\n   * Distance threshold for determining if the action is \"flick\" or \"swipe\".\r\n   * When a drag distance is over this value, the action will be treated as \"swipe\", not \"flick\".\r\n   *\r\n   * @type {number}\r\n   */\n  swipeDistanceThreshold: 150,\n\n  /**\r\n   * Velocity threshold for determining if the action is \"flick\" or \"swipe\".\r\n   * Around 0.5 is recommended.\r\n   *\r\n   * @type {number}\r\n   */\n  flickVelocityThreshold: .6,\n\n  /**\r\n   * Determine power of flick. The larger number this is, the farther a slider runs by flick.\r\n   * Around 500 is recommended.\r\n   *\r\n   * @type {number}\r\n   */\n  flickPower: 600,\n\n  /**\r\n   * Limit a number of pages to move by flick.\r\n   *\r\n   * @type {number}\r\n   */\n  flickMaxPages: 1,\n\n  /**\r\n   * Slider direction.\r\n   * - 'ltr': Left to right.\r\n   * - 'rtl': Right to left.\r\n   * - 'ttb': Top to bottom.\r\n   *\r\n   * @type {string}\r\n   */\n  direction: 'ltr',\n\n  /**\r\n   * Set img src to background-image of its parent element.\r\n   * Images with various sizes can be displayed as same dimension without cropping work.\r\n   * fixedHeight or heightRatio is required.\r\n   *\r\n   * @type {boolean}\r\n   */\n  cover: false,\n\n  /**\r\n   * Whether to enable accessibility(aria and screen reader texts) or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n  accessibility: true,\n\n  /**\r\n   * Whether to add tabindex=\"0\" to visible slides or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n  slideFocus: true,\n\n  /**\r\n   * Determine if a slider is navigation for another.\r\n   * Use \"sync\" API to synchronize two sliders.\r\n   *\r\n   * @type {boolean}\r\n   */\n  isNavigation: false,\n\n  /**\r\n   * Whether to trim spaces before the fist slide or after the last one when \"focus\" is not 0.\r\n   *\r\n   * @type {boolean}\r\n   */\n  trimSpace: true,\n\n  /**\r\n   * The \"is-active\" class is added after transition as default.\r\n   * If true, it will be added before move.\r\n   *\r\n   * @type {boolean}\r\n   */\n  updateOnMove: false,\n\n  /**\r\n   * Throttle duration in milliseconds for the resize event.\r\n   *\r\n   * @type {number}\r\n   */\n  throttle: 100,\n\n  /**\r\n   * Whether to destroy a slider or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n  destroy: false,\n\n  /**\r\n   * Options for specific breakpoints.\r\n   *\r\n   * @example\r\n   * {\r\n   *   1000: {\r\n   *     perPage: 3,\r\n   *     gap: 20\r\n   *   },\r\n   *   600: {\r\n   *     perPage: 1,\r\n   *     gap: 5,\r\n   *   }\r\n   * }\r\n   *\r\n   * @type {boolean|Object}\r\n   */\n  breakpoints: false,\n\n  /**\r\n   * Collection of class names.\r\n   *\r\n   * @see ./classes.js\r\n   *\r\n   * @type {Object}\r\n   */\n  classes: ELEMENT_CLASSES,\n\n  /**\r\n   * Collection of i18n texts.\r\n   *\r\n   * @see ./i18n.js\r\n   *\r\n   * @type {Object}\r\n   */\n  i18n: I18N\n};\n;// CONCATENATED MODULE: ./src/js/constants/states.js\n/**\r\n * Export state constants.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Splide has been just created.\r\n *\r\n * @type {number}\r\n */\nvar CREATED = 1;\n/**\r\n * All components have been mounted and initialized.\r\n *\r\n * @type {number}\r\n */\n\nvar MOUNTED = 2;\n/**\r\n * Splide is ready for transition.\r\n *\r\n * @type {number}\r\n */\n\nvar IDLE = 3;\n/**\r\n * Splide is moving.\r\n *\r\n * @type {number}\r\n */\n\nvar MOVING = 4;\n/**\r\n * Splide is moving.\r\n *\r\n * @type {number}\r\n */\n\nvar DESTROYED = 5;\n;// CONCATENATED MODULE: ./src/js/splide.js\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\r\n * The main class for applying Splide to an element.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\n\n\n\n/**\r\n * The main class for applying Splide to an element,\r\n * providing some APIs to control the behavior.\r\n */\n\nvar Splide = /*#__PURE__*/function () {\n  /**\r\n   * Splide constructor.\r\n   *\r\n   * @throws {Error} When the given root element or selector is invalid.\r\n   *\r\n   * @param {Element|string}  root       - A selector for a root element or an element itself.\r\n   * @param {Object}          options    - Optional. Options to change default behaviour.\r\n   * @param {Object}          Components - Optional. Components.\r\n   */\n  function Splide(root, options, Components) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (Components === void 0) {\n      Components = {};\n    }\n\n    this.root = root instanceof Element ? root : document.querySelector(root);\n    exist(this.root, 'An invalid element/selector was given.');\n    this.Components = null;\n    this.Event = core_event();\n    this.State = state(CREATED);\n    this.STATES = states_namespaceObject;\n    this._o = merge(DEFAULTS, options);\n    this._i = 0;\n    this._c = Components;\n    this._e = {}; // Extensions\n\n    this._t = null; // Transition\n  }\n  /**\r\n   * Compose and mount components.\r\n   *\r\n   * @param {Object}   Extensions - Optional. Additional components.\r\n   * @param {function} Transition - Optional. Set a custom transition component.\r\n   *\r\n   * @return {Splide|undefined} - This instance or undefined if an exception occurred.\r\n   */\n\n\n  var _proto = Splide.prototype;\n\n  _proto.mount = function mount(Extensions, Transition) {\n    var _this = this;\n\n    if (Extensions === void 0) {\n      Extensions = this._e;\n    }\n\n    if (Transition === void 0) {\n      Transition = this._t;\n    }\n\n    // Reset the state.\n    this.State.set(CREATED);\n    this._e = Extensions;\n    this._t = Transition;\n    this.Components = compose(this, merge(this._c, Extensions), Transition);\n\n    try {\n      each(this.Components, function (component, key) {\n        var required = component.required;\n\n        if (required === undefined || required) {\n          component.mount && component.mount();\n        } else {\n          delete _this.Components[key];\n        }\n      });\n    } catch (e) {\n      error(e.message);\n      return;\n    }\n\n    var State = this.State;\n    State.set(MOUNTED);\n    each(this.Components, function (component) {\n      component.mounted && component.mounted();\n    });\n    this.emit('mounted');\n    State.set(IDLE);\n    this.emit('ready');\n    applyStyle(this.root, {\n      visibility: 'visible'\n    });\n    this.on('move drag', function () {\n      return State.set(MOVING);\n    }).on('moved dragged', function () {\n      return State.set(IDLE);\n    });\n    return this;\n  }\n  /**\r\n   * Set sync target.\r\n   *\r\n   * @param {Splide} splide - A Splide instance.\r\n   *\r\n   * @return {Splide} - This instance.\r\n   */\n  ;\n\n  _proto.sync = function sync(splide) {\n    this.sibling = splide;\n    return this;\n  }\n  /**\r\n   * Register callback fired on the given event(s).\r\n   *\r\n   * @param {string}   events  - An event name. Use space to separate multiple events.\r\n   *                             Also, namespace is accepted by dot, such as 'resize.{namespace}'.\r\n   * @param {function} handler - A callback function.\r\n   * @param {Element}  elm     - Optional. Native event will be listened to when this arg is provided.\r\n   * @param {Object}   options - Optional. Options for addEventListener.\r\n   *\r\n   * @return {Splide} - This instance.\r\n   */\n  ;\n\n  _proto.on = function on(events, handler, elm, options) {\n    if (elm === void 0) {\n      elm = null;\n    }\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.Event.on(events, handler, elm, options);\n    return this;\n  }\n  /**\r\n   * Unsubscribe the given event.\r\n   *\r\n   * @param {string}  events - A event name.\r\n   * @param {Element} elm    - Optional. removeEventListener() will be called when this arg is provided.\r\n   *\r\n   * @return {Splide} - This instance.\r\n   */\n  ;\n\n  _proto.off = function off(events, elm) {\n    if (elm === void 0) {\n      elm = null;\n    }\n\n    this.Event.off(events, elm);\n    return this;\n  }\n  /**\r\n   * Emit an event.\r\n   *\r\n   * @param {string} event - An event name.\r\n   * @param {*}      args  - Any number of arguments passed to handlers.\r\n   */\n  ;\n\n  _proto.emit = function emit(event) {\n    var _this$Event;\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    (_this$Event = this.Event).emit.apply(_this$Event, [event].concat(args));\n\n    return this;\n  }\n  /**\r\n   * Go to the slide specified by the given control.\r\n   *\r\n   * @param {string|number} control - A control pattern.\r\n   * @param {boolean}       wait    - Optional. Whether to wait for transition.\r\n   */\n  ;\n\n  _proto.go = function go(control, wait) {\n    if (wait === void 0) {\n      wait = this.options.waitForTransition;\n    }\n\n    if (this.State.is(IDLE) || this.State.is(MOVING) && !wait) {\n      this.Components.Controller.go(control, false);\n    }\n\n    return this;\n  }\n  /**\r\n   * Verify whether the slider type is the given one or not.\r\n   *\r\n   * @param {string} type - A slider type.\r\n   *\r\n   * @return {boolean} - True if the slider type is the provided type or false if not.\r\n   */\n  ;\n\n  _proto.is = function is(type) {\n    return type === this._o.type;\n  }\n  /**\r\n   * Insert a slide.\r\n   *\r\n   * @param {Element|string} slide - A slide element to be added.\r\n   * @param {number}         index - A slide will be added at the position.\r\n   */\n  ;\n\n  _proto.add = function add(slide, index) {\n    if (index === void 0) {\n      index = -1;\n    }\n\n    this.Components.Elements.add(slide, index, this.refresh.bind(this));\n    return this;\n  }\n  /**\r\n   * Remove the slide designated by the index.\r\n   *\r\n   * @param {number} index - A slide index.\r\n   */\n  ;\n\n  _proto.remove = function remove(index) {\n    this.Components.Elements.remove(index);\n    this.refresh();\n    return this;\n  }\n  /**\r\n   * Destroy all Slide objects and clones and recreate them again.\r\n   */\n  ;\n\n  _proto.refresh = function refresh() {\n    this.emit('refresh:before').emit('refresh').emit('resize');\n    return this;\n  }\n  /**\r\n   * Destroy the Splide.\r\n   * \"Completely\" boolean is mainly for breakpoints.\r\n   *\r\n   * @param {boolean} completely - Destroy completely.\r\n   */\n  ;\n\n  _proto.destroy = function destroy(completely) {\n    var _this2 = this;\n\n    if (completely === void 0) {\n      completely = true;\n    }\n\n    // Postpone destroy because it should be done after mount.\n    if (this.State.is(CREATED)) {\n      this.on('ready', function () {\n        return _this2.destroy(completely);\n      });\n      return;\n    }\n\n    values(this.Components).reverse().forEach(function (component) {\n      component.destroy && component.destroy(completely);\n    });\n    this.emit('destroy', completely); // Destroy all event handlers, including ones for native events.\n\n    this.Event.destroy();\n    this.State.set(DESTROYED);\n    return this;\n  }\n  /**\r\n   * Return the current slide index.\r\n   *\r\n   * @return {number} - The current slide index.\r\n   // */\n  ;\n\n  _createClass(Splide, [{\n    key: \"index\",\n    get: function get() {\n      return this._i;\n    }\n    /**\r\n     * Set the current slide index.\r\n     *\r\n     * @param {number|string} index - A new index.\r\n     */\n    ,\n    set: function set(index) {\n      this._i = parseInt(index);\n    }\n    /**\r\n     * Return length of slides.\r\n     * This is an alias of Elements.length.\r\n     *\r\n     * @return {number} - A number of slides.\r\n     */\n\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.Components.Elements.length;\n    }\n    /**\r\n     * Return options.\r\n     *\r\n     * @return {Object} - Options object.\r\n     */\n\n  }, {\n    key: \"options\",\n    get: function get() {\n      return this._o;\n    }\n    /**\r\n     * Set options with merging the given object to the current one.\r\n     *\r\n     * @param {Object} options - New options.\r\n     */\n    ,\n    set: function set(options) {\n      var created = this.State.is(CREATED);\n\n      if (!created) {\n        this.emit('update');\n      }\n\n      this._o = merge(this._o, options);\n\n      if (!created) {\n        this.emit('updated', this._o);\n      }\n    }\n    /**\r\n     * Return the class list.\r\n     * This is an alias of Splide.options.classList.\r\n     *\r\n     * @return {Object} - An object containing all class list.\r\n     */\n\n  }, {\n    key: \"classes\",\n    get: function get() {\n      return this._o.classes;\n    }\n    /**\r\n     * Return the i18n strings.\r\n     * This is an alias of Splide.options.i18n.\r\n     *\r\n     * @return {Object} - An object containing all i18n strings.\r\n     */\n\n  }, {\n    key: \"i18n\",\n    get: function get() {\n      return this._o.i18n;\n    }\n  }]);\n\n  return Splide;\n}();\n\n\n;// CONCATENATED MODULE: ./src/js/components/options/index.js\n/**\r\n * The component for initializing options.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The component for initializing options.\r\n *\r\n * @param {Splide} Splide - A Splide instance.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const options = (function (Splide) {\n  /**\r\n   * Retrieve options from the data attribute.\r\n   * Note that IE10 doesn't support dataset property.\r\n   *\r\n   * @type {string}\r\n   */\n  var options = getAttribute(Splide.root, 'data-splide');\n\n  if (options) {\n    try {\n      Splide.options = JSON.parse(options);\n    } catch (e) {\n      error(e.message);\n    }\n  }\n\n  return {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      if (Splide.State.is(CREATED)) {\n        Splide.index = Splide.options.start;\n      }\n    }\n  };\n});\n;// CONCATENATED MODULE: ./src/js/constants/directions.js\n/**\r\n * Export layout modes.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Enumerate slides from left to right.\r\n *\r\n * @type {string}\r\n */\nvar LTR = 'ltr';\n/**\r\n * Enumerate slides from right to left.\r\n *\r\n * @type {string}\r\n */\n\nvar RTL = 'rtl';\n/**\r\n * Enumerate slides in a col.\r\n *\r\n * @type {string}\r\n */\n\nvar TTB = 'ttb';\n;// CONCATENATED MODULE: ./src/js/components/elements/slide.js\n/**\r\n * The sub component for handling each slide.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\n\n/**\r\n * Events for restoring original styles.\r\n *\r\n * @type {string}\r\n */\n\nvar STYLE_RESTORE_EVENTS = 'update.slide';\n/**\r\n * The sub component for handling each slide.\r\n *\r\n * @param {Splide}  Splide    - A Splide instance.\r\n * @param {number}  index     - An unique slide index.\r\n * @param {number}  realIndex - Clones should pass a real slide index.\r\n * @param {Element} slide     - A slide element.\r\n *\r\n * @return {Object} - The sub component object.\r\n */\n\n/* harmony default export */ const elements_slide = (function (Splide, index, realIndex, slide) {\n  /**\r\n   * Whether to update \"is-active\" class before or after transition.\r\n   *\r\n   * @type {boolean}\r\n   */\n  var updateOnMove = Splide.options.updateOnMove;\n  /**\r\n   * Events when the slide status is updated.\r\n   * Append a namespace to remove listeners later.\r\n   *\r\n   * @type {string}\r\n   */\n\n  var STATUS_UPDATE_EVENTS = 'ready.slide updated.slide resized.slide moved.slide' + (updateOnMove ? ' move.slide' : '');\n  /**\r\n   * Slide sub component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Slide = {\n    /**\r\n     * Slide element.\r\n     *\r\n     * @type {Element}\r\n     */\n    slide: slide,\n\n    /**\r\n     * Slide index.\r\n     *\r\n     * @type {number}\r\n     */\n    index: index,\n\n    /**\r\n     * Real index for clones.\r\n     *\r\n     * @type {number}\r\n     */\n    realIndex: realIndex,\n\n    /**\r\n     * Container element if available.\r\n     *\r\n     * @type {Element|undefined}\r\n     */\n    container: child(slide, Splide.classes.container),\n\n    /**\r\n     * Whether this is a cloned slide or not.\r\n     *\r\n     * @type {boolean}\r\n     */\n    isClone: realIndex > -1,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      var _this = this;\n\n      if (!this.isClone) {\n        slide.id = Splide.root.id + \"-slide\" + pad(index + 1);\n      }\n\n      Splide.on(STATUS_UPDATE_EVENTS, function () {\n        return _this.update();\n      }).on(STYLE_RESTORE_EVENTS, restoreStyles).on('click', function () {\n        return Splide.emit('click', _this);\n      }, slide);\n      /*\r\n       * Add \"is-active\" class to a clone element temporarily\r\n       * and it will be removed on \"moved\" event.\r\n       */\n\n      if (updateOnMove) {\n        Splide.on('move.slide', function (newIndex) {\n          if (newIndex === realIndex) {\n            _update(true, false);\n          }\n        });\n      } // Make sure the slide is shown.\n\n\n      applyStyle(slide, {\n        display: ''\n      }); // Hold the original styles.\n\n      this.styles = getAttribute(slide, 'style') || '';\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      Splide.off(STATUS_UPDATE_EVENTS).off(STYLE_RESTORE_EVENTS).off('click', slide);\n      removeClass(slide, values(STATUS_CLASSES));\n      restoreStyles();\n      removeAttribute(this.container, 'style');\n    },\n\n    /**\r\n     * Update active and visible status.\r\n     */\n    update: function update() {\n      _update(this.isActive(), false);\n\n      _update(this.isVisible(), true);\n    },\n\n    /**\r\n     * Check whether this slide is active or not.\r\n     *\r\n     * @return {boolean} - True if the slide is active or false if not.\r\n     */\n    isActive: function isActive() {\n      return Splide.index === index;\n    },\n\n    /**\r\n     * Check whether this slide is visible in the viewport or not.\r\n     *\r\n     * @return {boolean} - True if the slide is visible or false if not.\r\n     */\n    isVisible: function isVisible() {\n      var active = this.isActive();\n\n      if (Splide.is(FADE) || active) {\n        return active;\n      }\n\n      var ceil = Math.ceil;\n      var trackRect = getRect(Splide.Components.Elements.track);\n      var slideRect = getRect(slide);\n\n      if (Splide.options.direction === TTB) {\n        return trackRect.top <= slideRect.top && slideRect.bottom <= ceil(trackRect.bottom);\n      }\n\n      return trackRect.left <= slideRect.left && slideRect.right <= ceil(trackRect.right);\n    },\n\n    /**\r\n     * Calculate how far this slide is from another slide and\r\n     * return true if the distance is within the given number.\r\n     *\r\n     * @param {number} from   - Index of a target slide.\r\n     * @param {number} within - True if the slide is within this number.\r\n     *\r\n     * @return {boolean} - True if the slide is within the number or false otherwise.\r\n     */\n    isWithin: function isWithin(from, within) {\n      var diff = Math.abs(from - index);\n\n      if (!Splide.is(SLIDE) && !this.isClone) {\n        diff = Math.min(diff, Splide.length - diff);\n      }\n\n      return diff < within;\n    }\n  };\n  /**\r\n   * Update classes for activity or visibility.\r\n   *\r\n   * @param {boolean} active        - Is active/visible or not.\r\n   * @param {boolean} forVisibility - Toggle classes for activity or visibility.\r\n   */\n\n  function _update(active, forVisibility) {\n    var type = forVisibility ? 'visible' : 'active';\n    var className = STATUS_CLASSES[type];\n\n    if (active) {\n      addClass(slide, className);\n      Splide.emit(\"\" + type, Slide);\n    } else {\n      if (hasClass(slide, className)) {\n        removeClass(slide, className);\n        Splide.emit(\"\" + (forVisibility ? 'hidden' : 'inactive'), Slide);\n      }\n    }\n  }\n  /**\r\n   * Restore the original styles.\r\n   */\n\n\n  function restoreStyles() {\n    setAttribute(slide, 'style', Slide.styles);\n  }\n\n  return Slide;\n});\n;// CONCATENATED MODULE: ./src/js/components/elements/index.js\n/**\r\n * The component for main elements.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\n/**\r\n * The property name for UID stored in a window object.\r\n *\r\n * @type {string}\r\n */\n\nvar UID_NAME = 'uid';\n/**\r\n * The component for main elements.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const components_elements = (function (Splide, Components) {\n  /**\r\n   * Hold the root element.\r\n   *\r\n   * @type {Element}\r\n   */\n  var root = Splide.root;\n  /**\r\n   * Hold the class list.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var classes = Splide.classes;\n  /**\r\n   * Store Slide objects.\r\n   *\r\n   * @type {Array}\r\n   */\n\n  var Slides = [];\n  /*\r\n   * Assign unique ID to the root element if it doesn't have the one.\r\n   * Note that IE doesn't support padStart() to fill the uid by 0.\r\n   */\n\n  if (!root.id) {\n    window.splide = window.splide || {};\n    var uid = window.splide[UID_NAME] || 0;\n    window.splide[UID_NAME] = ++uid;\n    root.id = \"splide\" + pad(uid);\n  }\n  /**\r\n   * Elements component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n\n  var Elements = {\n    /**\r\n     * Called when the component is mounted.\r\n     * Collect main elements and store them as member properties.\r\n     */\n    mount: function mount() {\n      var _this = this;\n\n      this.init();\n      Splide.on('refresh', function () {\n        _this.destroy();\n\n        _this.init();\n      }).on('updated', function () {\n        removeClass(root, getClasses());\n        addClass(root, getClasses());\n      });\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      Slides.forEach(function (Slide) {\n        Slide.destroy();\n      });\n      Slides = [];\n      removeClass(root, getClasses());\n    },\n\n    /**\r\n     * Initialization.\r\n     */\n    init: function init() {\n      var _this2 = this;\n\n      collect();\n      addClass(root, getClasses());\n      this.slides.forEach(function (slide, index) {\n        _this2.register(slide, index, -1);\n      });\n    },\n\n    /**\r\n     * Register a slide to create a Slide object and handle its behavior.\r\n     *\r\n     * @param {Element} slide     - A slide element.\r\n     * @param {number}  index     - A unique index. This can be negative.\r\n     * @param {number}  realIndex - A real index for clones. Set -1 for real slides.\r\n     */\n    register: function register(slide, index, realIndex) {\n      var SlideObject = elements_slide(Splide, index, realIndex, slide);\n      SlideObject.mount();\n      Slides.push(SlideObject);\n    },\n\n    /**\r\n     * Return the Slide object designated by the index.\r\n     * Note that \"find\" is not supported by IE.\r\n     *\r\n     * @return {Object|undefined} - A Slide object if available. Undefined if not.\r\n     */\n    getSlide: function getSlide(index) {\n      return Slides.filter(function (Slide) {\n        return Slide.index === index;\n      })[0];\n    },\n\n    /**\r\n     * Return all Slide objects.\r\n     *\r\n     * @param {boolean} includeClones - Whether to include cloned slides or not.\r\n     *\r\n     * @return {Object[]} - Slide objects.\r\n     */\n    getSlides: function getSlides(includeClones) {\n      return includeClones ? Slides : Slides.filter(function (Slide) {\n        return !Slide.isClone;\n      });\n    },\n\n    /**\r\n     * Return Slide objects belonging to the given page.\r\n     *\r\n     * @param {number} page - A page number.\r\n     *\r\n     * @return {Object[]} - An array containing Slide objects.\r\n     */\n    getSlidesByPage: function getSlidesByPage(page) {\n      var idx = Components.Controller.toIndex(page);\n      var options = Splide.options;\n      var max = options.focus !== false ? 1 : options.perPage;\n      return Slides.filter(function (_ref) {\n        var index = _ref.index;\n        return idx <= index && index < idx + max;\n      });\n    },\n\n    /**\r\n     * Insert a slide to a slider.\r\n     * Need to refresh Splide after adding a slide.\r\n     *\r\n     * @param {Node|string} slide    - A slide element to be added.\r\n     * @param {number}      index    - A slide will be added at the position.\r\n     * @param {Function}    callback - Called right after the slide is added to the DOM tree.\r\n     */\n    add: function add(slide, index, callback) {\n      if (typeof slide === 'string') {\n        slide = domify(slide);\n      }\n\n      if (slide instanceof Element) {\n        var ref = this.slides[index]; // This will be removed in mount() of a Slide component.\n\n        applyStyle(slide, {\n          display: 'none'\n        });\n\n        if (ref) {\n          before(slide, ref);\n          this.slides.splice(index, 0, slide);\n        } else {\n          append(this.list, slide);\n          this.slides.push(slide);\n        }\n\n        loaded(slide, function () {\n          callback && callback(slide);\n        });\n      }\n    },\n\n    /**\r\n     * Remove a slide from a slider.\r\n     * Need to refresh Splide after removing a slide.\r\n     *\r\n     * @param index - Slide index.\r\n     */\n    remove: function remove(index) {\n      dom_remove(this.slides.splice(index, 1)[0]);\n    },\n\n    /**\r\n     * Trigger the provided callback for each Slide object.\r\n     *\r\n     * @param {Function} callback - A callback function. The first argument will be the Slide object.\r\n     */\n    each: function each(callback) {\n      Slides.forEach(callback);\n    },\n\n    /**\r\n     * Return slides length without clones.\r\n     *\r\n     * @return {number} - Slide length.\r\n     */\n    get length() {\n      return this.slides.length;\n    },\n\n    /**\r\n     * Return \"SlideObjects\" length including clones.\r\n     *\r\n     * @return {number} - Slide length including clones.\r\n     */\n    get total() {\n      return Slides.length;\n    }\n\n  };\n  /**\r\n   * Collect elements.\r\n   */\n\n  function collect() {\n    Elements.slider = child(root, classes.slider);\n    Elements.track = find(root, \".\" + classes.track);\n    Elements.list = child(Elements.track, classes.list);\n    exist(Elements.track && Elements.list, 'Track or list was not found.');\n    Elements.slides = children(Elements.list, classes.slide);\n    var arrows = findParts(classes.arrows);\n    Elements.arrows = {\n      prev: find(arrows, \".\" + classes.prev),\n      next: find(arrows, \".\" + classes.next)\n    };\n    var autoplay = findParts(classes.autoplay);\n    Elements.bar = find(findParts(classes.progress), \".\" + classes.bar);\n    Elements.play = find(autoplay, \".\" + classes.play);\n    Elements.pause = find(autoplay, \".\" + classes.pause);\n    Elements.track.id = Elements.track.id || root.id + \"-track\";\n    Elements.list.id = Elements.list.id || root.id + \"-list\";\n  }\n  /**\r\n   * Return class names for the root element.\r\n   */\n\n\n  function getClasses() {\n    var rootClass = classes.root;\n    var options = Splide.options;\n    return [rootClass + \"--\" + options.type, rootClass + \"--\" + options.direction, options.drag ? rootClass + \"--draggable\" : '', options.isNavigation ? rootClass + \"--nav\" : '', STATUS_CLASSES.active];\n  }\n  /**\r\n   * Find parts only from children of the root or track.\r\n   *\r\n   * @return {Element} - A found element or undefined.\r\n   */\n\n\n  function findParts(className) {\n    return child(root, className) || child(Elements.slider, className);\n  }\n\n  return Elements;\n});\n;// CONCATENATED MODULE: ./src/js/components/controller/index.js\n/**\r\n * The component for controlling the track.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\nvar floor = Math.floor;\n/**\r\n * The component for controlling the track.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const controller = (function (Splide, Components) {\n  /**\r\n   * Store current options.\r\n   *\r\n   * @type {Object}\r\n   */\n  var options;\n  /**\r\n   * True if the slide is LOOP mode.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isLoop;\n  /**\r\n   * Controller component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Controller = {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      options = Splide.options;\n      isLoop = Splide.is(LOOP);\n      bind();\n    },\n\n    /**\r\n     * Make track run by the given control.\r\n     * - \"+{i}\" : Increment the slide index by i.\r\n     * - \"-{i}\" : Decrement the slide index by i.\r\n     * - \"{i}\"  : Go to the slide whose index is i.\r\n     * - \">\"    : Go to next page.\r\n     * - \"<\"    : Go to prev page.\r\n     * - \">{i}\" : Go to page i.\r\n     *\r\n     * @param {string|number} control  - A control pattern.\r\n     * @param {boolean}       silently - Go to the destination without event emission.\r\n     */\n    go: function go(control, silently) {\n      var destIndex = this.trim(this.parse(control));\n      Components.Track.go(destIndex, this.rewind(destIndex), silently);\n    },\n\n    /**\r\n     * Parse the given control and return the destination index for the track.\r\n     *\r\n     * @param {string} control - A control target pattern.\r\n     *\r\n     * @return {number} - A parsed target.\r\n     */\n    parse: function parse(control) {\n      var index = Splide.index;\n      var matches = String(control).match(/([+\\-<>]+)(\\d+)?/);\n      var indicator = matches ? matches[1] : '';\n      var number = matches ? parseInt(matches[2]) : 0;\n\n      switch (indicator) {\n        case '+':\n          index += number || 1;\n          break;\n\n        case '-':\n          index -= number || 1;\n          break;\n\n        case '>':\n        case '<':\n          index = parsePage(number, index, indicator === '<');\n          break;\n\n        default:\n          index = parseInt(control);\n      }\n\n      return index;\n    },\n\n    /**\r\n     * Compute index from the given page number.\r\n     *\r\n     * @param {number} page - Page number.\r\n     *\r\n     * @return {number} - A computed page number.\r\n     */\n    toIndex: function toIndex(page) {\n      if (hasFocus()) {\n        return page;\n      }\n\n      var length = Splide.length;\n      var perPage = options.perPage;\n      var index = page * perPage;\n      index = index - (this.pageLength * perPage - length) * floor(index / length); // Adjustment for the last page.\n\n      if (length - perPage <= index && index < length) {\n        index = length - perPage;\n      }\n\n      return index;\n    },\n\n    /**\r\n     * Compute page number from the given slide index.\r\n     *\r\n     * @param {number} index - Slide index.\r\n     *\r\n     * @return {number} - A computed page number.\r\n     */\n    toPage: function toPage(index) {\n      if (hasFocus()) {\n        return index;\n      }\n\n      var length = Splide.length;\n      var perPage = options.perPage; // Make the last \"perPage\" number of slides belong to the last page.\n\n      if (length - perPage <= index && index < length) {\n        return floor((length - 1) / perPage);\n      }\n\n      return floor(index / perPage);\n    },\n\n    /**\r\n     * Trim the given index according to the current mode.\r\n     * Index being returned could be less than 0 or greater than the length in Loop mode.\r\n     *\r\n     * @param {number} index - An index being trimmed.\r\n     *\r\n     * @return {number} - A trimmed index.\r\n     */\n    trim: function trim(index) {\n      if (!isLoop) {\n        index = options.rewind ? this.rewind(index) : between(index, 0, this.edgeIndex);\n      }\n\n      return index;\n    },\n\n    /**\r\n     * Rewind the given index if it's out of range.\r\n     *\r\n     * @param {number} index - An index.\r\n     *\r\n     * @return {number} - A rewound index.\r\n     */\n    rewind: function rewind(index) {\n      var edge = this.edgeIndex;\n\n      if (isLoop) {\n        while (index > edge) {\n          index -= edge + 1;\n        }\n\n        while (index < 0) {\n          index += edge + 1;\n        }\n      } else {\n        if (index > edge) {\n          index = 0;\n        } else if (index < 0) {\n          index = edge;\n        }\n      }\n\n      return index;\n    },\n\n    /**\r\n     * Check if the direction is \"rtl\" or not.\r\n     *\r\n     * @return {boolean} - True if \"rtl\" or false if not.\r\n     */\n    isRtl: function isRtl() {\n      return options.direction === RTL;\n    },\n\n    /**\r\n     * Return the page length.\r\n     *\r\n     * @return {number} - Max page number.\r\n     */\n    get pageLength() {\n      var length = Splide.length;\n      return hasFocus() ? length : Math.ceil(length / options.perPage);\n    },\n\n    /**\r\n     * Return the edge index.\r\n     *\r\n     * @return {number} - Edge index.\r\n     */\n    get edgeIndex() {\n      var length = Splide.length;\n\n      if (!length) {\n        return 0;\n      }\n\n      if (hasFocus() || options.isNavigation || isLoop) {\n        return length - 1;\n      }\n\n      return length - options.perPage;\n    },\n\n    /**\r\n     * Return the index of the previous slide.\r\n     *\r\n     * @return {number} - The index of the previous slide if available. -1 otherwise.\r\n     */\n    get prevIndex() {\n      var prev = Splide.index - 1;\n\n      if (isLoop || options.rewind) {\n        prev = this.rewind(prev);\n      }\n\n      return prev > -1 ? prev : -1;\n    },\n\n    /**\r\n     * Return the index of the next slide.\r\n     *\r\n     * @return {number} - The index of the next slide if available. -1 otherwise.\r\n     */\n    get nextIndex() {\n      var next = Splide.index + 1;\n\n      if (isLoop || options.rewind) {\n        next = this.rewind(next);\n      }\n\n      return Splide.index < next && next <= this.edgeIndex || next === 0 ? next : -1;\n    }\n\n  };\n  /**\r\n   * Listen to some events.\r\n   */\n\n  function bind() {\n    Splide.on('move', function (newIndex) {\n      Splide.index = newIndex;\n    }).on('updated refresh', function (newOptions) {\n      options = newOptions || options;\n      Splide.index = between(Splide.index, 0, Controller.edgeIndex);\n    });\n  }\n  /**\r\n   * Verify if the focus option is available or not.\r\n   *\r\n   * @return {boolean} - True if a slider has the focus option.\r\n   */\n\n\n  function hasFocus() {\n    return options.focus !== false;\n  }\n  /**\r\n   * Return the next or previous page index computed by the page number and current index.\r\n   *\r\n   * @param {number}  number - Specify the page number.\r\n   * @param {number}  index  - Current index.\r\n   * @param {boolean} prev   - Prev or next.\r\n   *\r\n   * @return {number} - Slide index.\r\n   */\n\n\n  function parsePage(number, index, prev) {\n    if (number > -1) {\n      return Controller.toIndex(number);\n    }\n\n    var perMove = options.perMove;\n    var sign = prev ? -1 : 1;\n\n    if (perMove) {\n      return index + perMove * sign;\n    }\n\n    return Controller.toIndex(Controller.toPage(index) + sign);\n  }\n\n  return Controller;\n});\n;// CONCATENATED MODULE: ./src/js/components/track/index.js\n/**\r\n * The component for moving list in the track.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\nvar abs = Math.abs;\n/**\r\n * The component for moving list in the track.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const track = (function (Splide, Components) {\n  /**\r\n   * Hold the Layout component.\r\n   *\r\n   * @type {Object}\r\n   */\n  var Layout;\n  /**\r\n   * Hold the Layout component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Elements;\n  /**\r\n   * Store the list element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var list;\n  /**\r\n   * Whether the current direction is vertical or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isVertical = Splide.options.direction === TTB;\n  /**\r\n   * Whether the slider type is FADE or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isFade = Splide.is(FADE);\n  /**\r\n   * Whether the slider direction is RTL or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isRTL = Splide.options.direction === RTL;\n  /**\r\n   * This will be true while transitioning from the last index to the first one.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isLoopPending = false;\n  /**\r\n   * Sign for the direction. Only RTL mode uses the positive sign.\r\n   *\r\n   * @type {number}\r\n   */\n\n  var sign = isRTL ? 1 : -1;\n  /**\r\n   * Track component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Track = {\n    /**\r\n     * Make public the sign defined locally.\r\n     *\r\n     * @type {number}\r\n     */\n    sign: sign,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Elements = Components.Elements;\n      Layout = Components.Layout;\n      list = Elements.list;\n    },\n\n    /**\r\n     * Called after the component is mounted.\r\n     * The resize event must be registered after the Layout's one is done.\r\n     */\n    mounted: function mounted() {\n      var _this = this;\n\n      if (!isFade) {\n        this.jump(0);\n        Splide.on('mounted resize updated', function () {\n          _this.jump(Splide.index);\n        });\n      }\n    },\n\n    /**\r\n     * Go to the given destination index.\r\n     * After arriving there, the track is jump to the new index without animation, mainly for loop mode.\r\n     *\r\n     * @param {number}  destIndex - A destination index.\r\n     *                              This can be negative or greater than slides length for reaching clones.\r\n     * @param {number}  newIndex  - An actual new index. They are always same in Slide and Rewind mode.\r\n     * @param {boolean} silently  - If true, suppress emitting events.\r\n     */\n    go: function go(destIndex, newIndex, silently) {\n      var newPosition = getTrimmedPosition(destIndex);\n      var prevIndex = Splide.index; // Prevent any actions while transitioning from the last index to the first one for jump.\n\n      if (Splide.State.is(MOVING) && isLoopPending) {\n        return;\n      }\n\n      isLoopPending = destIndex !== newIndex;\n\n      if (!silently) {\n        Splide.emit('move', newIndex, prevIndex, destIndex);\n      }\n\n      if (Math.abs(newPosition - this.position) >= 1 || isFade) {\n        Components.Transition.start(destIndex, newIndex, prevIndex, this.toCoord(newPosition), function () {\n          onTransitionEnd(destIndex, newIndex, prevIndex, silently);\n        });\n      } else {\n        if (destIndex !== prevIndex && Splide.options.trimSpace === 'move') {\n          Components.Controller.go(destIndex + destIndex - prevIndex, silently);\n        } else {\n          onTransitionEnd(destIndex, newIndex, prevIndex, silently);\n        }\n      }\n    },\n\n    /**\r\n     * Move the track to the specified index.\r\n     *\r\n     * @param {number} index - A destination index where the track jumps.\r\n     */\n    jump: function jump(index) {\n      this.translate(getTrimmedPosition(index));\n    },\n\n    /**\r\n     * Set the list position by CSS translate property.\r\n     *\r\n     * @param {number} position - A new position value.\r\n     */\n    translate: function translate(position) {\n      applyStyle(list, {\n        transform: \"translate\" + (isVertical ? 'Y' : 'X') + \"(\" + position + \"px)\"\n      });\n    },\n\n    /**\r\n     * Cancel the transition and set the list position.\r\n     * Also, loop the slider if necessary.\r\n     */\n    cancel: function cancel() {\n      if (Splide.is(LOOP)) {\n        this.shift();\n      } else {\n        // Ensure the current position.\n        this.translate(this.position);\n      }\n\n      applyStyle(list, {\n        transition: ''\n      });\n    },\n\n    /**\r\n     * Shift the slider if it exceeds borders on the edge.\r\n     */\n    shift: function shift() {\n      var position = abs(this.position);\n      var left = abs(this.toPosition(0));\n      var right = abs(this.toPosition(Splide.length));\n      var innerSize = right - left;\n\n      if (position < left) {\n        position += innerSize;\n      } else if (position > right) {\n        position -= innerSize;\n      }\n\n      this.translate(sign * position);\n    },\n\n    /**\r\n     * Trim redundant spaces on the left or right edge if necessary.\r\n     *\r\n     * @param {number} position - Position value to be trimmed.\r\n     *\r\n     * @return {number} - Trimmed position.\r\n     */\n    trim: function trim(position) {\n      if (!Splide.options.trimSpace || Splide.is(LOOP)) {\n        return position;\n      }\n\n      var edge = sign * (Layout.totalSize() - Layout.size - Layout.gap);\n      return between(position, edge, 0);\n    },\n\n    /**\r\n     * Calculate the closest slide index from the given position.\r\n     *\r\n     * @param {number} position - A position converted to an slide index.\r\n     *\r\n     * @return {number} - The closest slide index.\r\n     */\n    toIndex: function toIndex(position) {\n      var _this2 = this;\n\n      var index = 0;\n      var minDistance = Infinity;\n      Elements.getSlides(true).forEach(function (Slide) {\n        var slideIndex = Slide.index;\n        var distance = abs(_this2.toPosition(slideIndex) - position);\n\n        if (distance < minDistance) {\n          minDistance = distance;\n          index = slideIndex;\n        }\n      });\n      return index;\n    },\n\n    /**\r\n     * Return coordinates object by the given position.\r\n     *\r\n     * @param {number} position - A position value.\r\n     *\r\n     * @return {Object} - A coordinates object.\r\n     */\n    toCoord: function toCoord(position) {\n      return {\n        x: isVertical ? 0 : position,\n        y: isVertical ? position : 0\n      };\n    },\n\n    /**\r\n     * Calculate the track position by a slide index.\r\n     *\r\n     * @param {number} index - Slide index.\r\n     *\r\n     * @return {Object} - Calculated position.\r\n     */\n    toPosition: function toPosition(index) {\n      var position = Layout.totalSize(index) - Layout.slideSize(index) - Layout.gap;\n      return sign * (position + this.offset(index));\n    },\n\n    /**\r\n     * Return the current offset value, considering direction.\r\n     *\r\n     * @return {number} - Offset amount.\r\n     */\n    offset: function offset(index) {\n      var focus = Splide.options.focus;\n      var slideSize = Layout.slideSize(index);\n\n      if (focus === 'center') {\n        return -(Layout.size - slideSize) / 2;\n      }\n\n      return -(parseInt(focus) || 0) * (slideSize + Layout.gap);\n    },\n\n    /**\r\n     * Return the current position.\r\n     * This returns the correct position even while transitioning by CSS.\r\n     *\r\n     * @return {number} - Current position.\r\n     */\n    get position() {\n      var prop = isVertical ? 'top' : isRTL ? 'right' : 'left';\n      return getRect(list)[prop] - (getRect(Elements.track)[prop] - Layout.padding[prop] * sign);\n    }\n\n  };\n  /**\r\n   * Called whenever slides arrive at a destination.\r\n   *\r\n   * @param {number}  destIndex - A destination index.\r\n   * @param {number}  newIndex  - A new index.\r\n   * @param {number}  prevIndex - A previous index.\r\n   * @param {boolean} silently  - If true, suppress emitting events.\r\n   */\n\n  function onTransitionEnd(destIndex, newIndex, prevIndex, silently) {\n    applyStyle(list, {\n      transition: ''\n    });\n    isLoopPending = false;\n\n    if (!isFade) {\n      Track.jump(newIndex);\n    }\n\n    if (!silently) {\n      Splide.emit('moved', newIndex, prevIndex, destIndex);\n    }\n  }\n  /**\r\n   * Convert index to the trimmed position.\r\n   *\r\n   * @return {number} - Trimmed position.\r\n   */\n\n\n  function getTrimmedPosition(index) {\n    return Track.trim(Track.toPosition(index));\n  }\n\n  return Track;\n});\n;// CONCATENATED MODULE: ./src/js/components/clones/index.js\n/**\r\n * The component for cloning some slides for \"loop\" mode of the track.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n/**\r\n * The component for cloning some slides for \"loop\" mode of the track.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const clones = (function (Splide, Components) {\n  /**\r\n   * Store information of all clones.\r\n   *\r\n   * @type {Array}\r\n   */\n  var clones = [];\n  /**\r\n   * Store the current clone count on one side.\r\n   *\r\n   * @type {number}\r\n   */\n\n  var cloneCount = 0;\n  /**\r\n   * Keep Elements component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Elements = Components.Elements;\n  /**\r\n   * Clones component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Clones = {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      var _this = this;\n\n      if (Splide.is(LOOP)) {\n        init();\n        Splide.on('refresh:before', function () {\n          _this.destroy();\n        }).on('refresh', init).on('resize', function () {\n          if (cloneCount !== getCloneCount()) {\n            // Destroy before refresh not to collect clones by the Elements component.\n            _this.destroy();\n\n            Splide.refresh();\n          }\n        });\n      }\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      dom_remove(clones);\n      clones = [];\n    },\n\n    /**\r\n     * Return all clones.\r\n     *\r\n     * @return {Element[]} - Cloned elements.\r\n     */\n    get clones() {\n      return clones;\n    },\n\n    /**\r\n     * Return clone length.\r\n     *\r\n     * @return {number} - A length of clones.\r\n     */\n    get length() {\n      return clones.length;\n    }\n\n  };\n  /**\r\n   * Initialization.\r\n   */\n\n  function init() {\n    Clones.destroy();\n    cloneCount = getCloneCount();\n    generateClones(cloneCount);\n  }\n  /**\r\n   * Generate and append/prepend clones.\r\n   *\r\n   * @param {number} count - The half number of clones.\r\n   */\n\n\n  function generateClones(count) {\n    var length = Elements.length,\n        register = Elements.register;\n\n    if (length) {\n      var slides = Elements.slides;\n\n      while (slides.length < count) {\n        slides = slides.concat(slides);\n      } // Clones after the last element.\n\n\n      slides.slice(0, count).forEach(function (elm, index) {\n        var clone = cloneDeeply(elm);\n        append(Elements.list, clone);\n        clones.push(clone);\n        register(clone, index + length, index % length);\n      }); // Clones before the first element.\n\n      slides.slice(-count).forEach(function (elm, index) {\n        var clone = cloneDeeply(elm);\n        before(clone, slides[0]);\n        clones.push(clone);\n        register(clone, index - count, (length + index - count % length) % length);\n      });\n    }\n  }\n  /**\r\n   * Return half count of clones to be generated.\r\n   * Clone count is determined by:\r\n   * - \"clones\" value in the options.\r\n   * - Number of slides that can be placed in a view in \"fixed\" mode.\r\n   * - Max pages a flick action can move.\r\n   * - Whether the slide length is enough for perPage.\r\n   *\r\n   * @return {number} - Count for clones.\r\n   */\n\n\n  function getCloneCount() {\n    var options = Splide.options;\n\n    if (options.clones) {\n      return options.clones;\n    } // Use the slide length in autoWidth mode because the number cannot be calculated.\n\n\n    var baseCount = options.autoWidth || options.autoHeight ? Elements.length : options.perPage;\n    var dimension = options.direction === TTB ? 'Height' : 'Width';\n    var fixedSize = toPixel(Splide.root, options[\"fixed\" + dimension]);\n\n    if (fixedSize) {\n      // Roughly calculate the count. This needs not to be strict.\n      baseCount = Math.ceil(Elements.track[\"client\" + dimension] / fixedSize);\n    }\n\n    return baseCount * (options.drag ? options.flickMaxPages + 1 : 1);\n  }\n  /**\r\n   * Clone deeply the given element.\r\n   *\r\n   * @param {Element} elm - An element being duplicated.\r\n   *\r\n   * @return {Node} - A cloned node(element).\r\n   */\n\n\n  function cloneDeeply(elm) {\n    var clone = elm.cloneNode(true);\n    addClass(clone, Splide.classes.clone); // ID should not be duplicated.\n\n    removeAttribute(clone, 'id');\n    return clone;\n  }\n\n  return Clones;\n});\n;// CONCATENATED MODULE: ./src/js/components/layout/directions/horizontal.js\n/**\r\n * The resolver component for horizontal layout.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The resolver component for horizontal layout.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The resolver object.\r\n */\n\n/* harmony default export */ const horizontal = (function (Splide, Components) {\n  /**\r\n   * Keep the Elements component.\r\n   *\r\n   * @type {string}\r\n   */\n  var Elements = Components.Elements;\n  /**\r\n   * Keep the root element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var root = Splide.root;\n  /**\r\n   * Keep the track element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var track;\n  /**\r\n   * Keep the latest options.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var options = Splide.options;\n  return {\n    /**\r\n     * Margin property name.\r\n     *\r\n     * @type {string}\r\n     */\n    margin: 'margin' + (options.direction === RTL ? 'Left' : 'Right'),\n\n    /**\r\n     * Always 0 because the height will be determined by inner contents.\r\n     *\r\n     * @type {number}\r\n     */\n    height: 0,\n\n    /**\r\n     * Initialization.\r\n     */\n    init: function init() {\n      this.resize();\n    },\n\n    /**\r\n     * Resize gap and padding.\r\n     * This must be called on init.\r\n     */\n    resize: function resize() {\n      options = Splide.options;\n      track = Elements.track;\n      this.gap = toPixel(root, options.gap);\n      var padding = options.padding;\n      var left = toPixel(root, padding.left || padding);\n      var right = toPixel(root, padding.right || padding);\n      this.padding = {\n        left: left,\n        right: right\n      };\n      applyStyle(track, {\n        paddingLeft: unit(left),\n        paddingRight: unit(right)\n      });\n    },\n\n    /**\r\n     * Return total width from the left of the list to the right of the slide specified by the provided index.\r\n     *\r\n     * @param {number} index - Optional. A slide index. If undefined, total width of the slider will be returned.\r\n     *\r\n     * @return {number} - Total width to the right side of the specified slide, or 0 for an invalid index.\r\n     */\n    totalWidth: function totalWidth(index) {\n      if (index === void 0) {\n        index = Splide.length - 1;\n      }\n\n      var Slide = Elements.getSlide(index);\n      var width = 0;\n\n      if (Slide) {\n        var slideRect = getRect(Slide.slide);\n        var listRect = getRect(Elements.list);\n\n        if (options.direction === RTL) {\n          width = listRect.right - slideRect.left;\n        } else {\n          width = slideRect.right - listRect.left;\n        }\n\n        width += this.gap;\n      }\n\n      return width;\n    },\n\n    /**\r\n     * Return the slide width in px.\r\n     *\r\n     * @param {number} index - Slide index.\r\n     *\r\n     * @return {number} - The slide width.\r\n     */\n    slideWidth: function slideWidth(index) {\n      if (options.autoWidth) {\n        var Slide = Elements.getSlide(index);\n        return Slide ? Slide.slide.offsetWidth : 0;\n      }\n\n      var width = options.fixedWidth || (this.width + this.gap) / options.perPage - this.gap;\n      return toPixel(root, width);\n    },\n\n    /**\r\n     * Return the slide height in px.\r\n     *\r\n     * @return {number} - The slide height.\r\n     */\n    slideHeight: function slideHeight() {\n      var height = options.height || options.fixedHeight || this.width * options.heightRatio;\n      return toPixel(root, height);\n    },\n\n    /**\r\n     * Return slider width without padding.\r\n     *\r\n     * @return {number} - Current slider width.\r\n     */\n    get width() {\n      return track.clientWidth - this.padding.left - this.padding.right;\n    }\n\n  };\n});\n;// CONCATENATED MODULE: ./src/js/components/layout/directions/vertical.js\n/**\r\n * The resolver component for vertical layout.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The resolver component for vertical layout.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The resolver object.\r\n */\n\n/* harmony default export */ const vertical = (function (Splide, Components) {\n  /**\r\n   * Keep the Elements component.\r\n   *\r\n   * @type {string}\r\n   */\n  var Elements = Components.Elements;\n  /**\r\n   * Keep the root element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var root = Splide.root;\n  /**\r\n   * Keep the track element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var track;\n  /**\r\n   * Keep the latest options.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var options;\n  return {\n    /**\r\n     * Margin property name.\r\n     *\r\n     * @type {string}\r\n     */\n    margin: 'marginBottom',\n\n    /**\r\n     * Initialization.\r\n     */\n    init: function init() {\n      this.resize();\n    },\n\n    /**\r\n     * Resize gap and padding.\r\n     * This must be called on init.\r\n     */\n    resize: function resize() {\n      options = Splide.options;\n      track = Elements.track;\n      this.gap = toPixel(root, options.gap);\n      var padding = options.padding;\n      var top = toPixel(root, padding.top || padding);\n      var bottom = toPixel(root, padding.bottom || padding);\n      this.padding = {\n        top: top,\n        bottom: bottom\n      };\n      applyStyle(track, {\n        paddingTop: unit(top),\n        paddingBottom: unit(bottom)\n      });\n    },\n\n    /**\r\n     * Return total height from the top of the list to the bottom of the slide specified by the provided index.\r\n     *\r\n     * @param {number} index - Optional. A slide index. If undefined, total height of the slider will be returned.\r\n     *\r\n     * @return {number} - Total height to the bottom of the specified slide, or 0 for an invalid index.\r\n     */\n    totalHeight: function totalHeight(index) {\n      if (index === void 0) {\n        index = Splide.length - 1;\n      }\n\n      var Slide = Elements.getSlide(index);\n\n      if (Slide) {\n        return getRect(Slide.slide).bottom - getRect(Elements.list).top + this.gap;\n      }\n\n      return 0;\n    },\n\n    /**\r\n     * Return the slide width in px.\r\n     *\r\n     * @return {number} - The slide width.\r\n     */\n    slideWidth: function slideWidth() {\n      return toPixel(root, options.fixedWidth || this.width);\n    },\n\n    /**\r\n     * Return the slide height in px.\r\n     *\r\n     * @param {number} index - Slide index.\r\n     *\r\n     * @return {number} - The slide height.\r\n     */\n    slideHeight: function slideHeight(index) {\n      if (options.autoHeight) {\n        var Slide = Elements.getSlide(index);\n        return Slide ? Slide.slide.offsetHeight : 0;\n      }\n\n      var height = options.fixedHeight || (this.height + this.gap) / options.perPage - this.gap;\n      return toPixel(root, height);\n    },\n\n    /**\r\n     * Return slider width without padding.\r\n     *\r\n     * @return {number} - Current slider width.\r\n     */\n    get width() {\n      return track.clientWidth;\n    },\n\n    /**\r\n     * Return slide height without padding.\r\n     *\r\n     * @return {number} - Slider height.\r\n     */\n    get height() {\n      var height = options.height || this.width * options.heightRatio;\n      exist(height, '\"height\" or \"heightRatio\" is missing.');\n      return toPixel(root, height) - this.padding.top - this.padding.bottom;\n    }\n\n  };\n});\n;// CONCATENATED MODULE: ./src/js/utils/time.js\n/**\r\n * A package of utility functions related with time.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Simple throttle function that controls how often the given function is executed.\r\n *\r\n * @param {function} func - A function to be throttled.\r\n * @param {number}   wait - Time in millisecond for interval of execution.\r\n *\r\n * @return {Function} - A debounced function.\r\n */\nfunction throttle(func, wait) {\n  var timeout; // Declare function by the \"function\" keyword to prevent \"this\" from being inherited.\n\n  return function () {\n    if (!timeout) {\n      timeout = setTimeout(function () {\n        func();\n        timeout = null;\n      }, wait);\n    }\n  };\n}\n/**\r\n * Custom setInterval function that provides progress rate as callback.\r\n *\r\n * @param {function} callback - A callback function fired every time the interval time passes.\r\n * @param {number}   interval - Interval duration in milliseconds.\r\n * @param {function} progress - A callback function fired whenever the progress goes.\r\n *\r\n * @return {Object} - An object containing play() and pause() functions.\r\n */\n\nfunction createInterval(callback, interval, progress) {\n  var _window = window,\n      requestAnimationFrame = _window.requestAnimationFrame;\n  var start,\n      elapse,\n      rate,\n      _pause = true;\n\n  var step = function step(timestamp) {\n    if (!_pause) {\n      if (!start) {\n        start = timestamp;\n\n        if (rate && rate < 1) {\n          start -= rate * interval;\n        }\n      }\n\n      elapse = timestamp - start;\n      rate = elapse / interval;\n\n      if (elapse >= interval) {\n        start = 0;\n        rate = 1;\n        callback();\n      }\n\n      if (progress) {\n        progress(rate);\n      }\n\n      requestAnimationFrame(step);\n    }\n  };\n\n  return {\n    pause: function pause() {\n      _pause = true;\n      start = 0;\n    },\n    play: function play(reset) {\n      start = 0;\n\n      if (reset) {\n        rate = 0;\n      }\n\n      if (_pause) {\n        _pause = false;\n        requestAnimationFrame(step);\n      }\n    }\n  };\n}\n;// CONCATENATED MODULE: ./src/js/components/layout/index.js\n/**\r\n * The component for handing slide layouts and their sizes.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\n\n\n/**\r\n * The component for handing slide layouts and their sizes.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const layout = (function (Splide, Components) {\n  /**\r\n   * Keep the Elements component.\r\n   *\r\n   * @type {string}\r\n   */\n  var Elements = Components.Elements;\n  /**\r\n   * Whether the slider is vertical or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isVertical = Splide.options.direction === TTB;\n  /**\r\n   * Layout component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Layout = object_assign({\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      bind();\n      init(); // The word \"size\" means width for a horizontal slider and height for a vertical slider.\n\n      this.totalSize = isVertical ? this.totalHeight : this.totalWidth;\n      this.slideSize = isVertical ? this.slideHeight : this.slideWidth;\n    },\n\n    /**\r\n     * Destroy the component.\r\n     */\n    destroy: function destroy() {\n      removeAttribute([Elements.list, Elements.track], 'style');\n    },\n\n    /**\r\n     * Return the slider height on the vertical mode or width on the horizontal mode.\r\n     *\r\n     * @return {number}\r\n     */\n    get size() {\n      return isVertical ? this.height : this.width;\n    }\n\n  }, isVertical ? vertical(Splide, Components) : horizontal(Splide, Components));\n  /**\r\n   * Init slider styles according to options.\r\n   */\n\n  function init() {\n    Layout.init();\n    applyStyle(Splide.root, {\n      maxWidth: unit(Splide.options.width)\n    });\n    Elements.each(function (Slide) {\n      Slide.slide.style[Layout.margin] = unit(Layout.gap);\n    });\n    resize();\n  }\n  /**\r\n   * Listen the resize native event with throttle.\r\n   * Initialize when the component is mounted or options are updated.\r\n   */\n\n\n  function bind() {\n    Splide.on('resize load', throttle(function () {\n      Splide.emit('resize');\n    }, Splide.options.throttle), window).on('resize', resize).on('updated refresh', init);\n  }\n  /**\r\n   * Resize the track and slide elements.\r\n   */\n\n\n  function resize() {\n    var options = Splide.options;\n    Layout.resize();\n    applyStyle(Elements.track, {\n      height: unit(Layout.height)\n    });\n    var slideHeight = options.autoHeight ? null : unit(Layout.slideHeight());\n    Elements.each(function (Slide) {\n      applyStyle(Slide.container, {\n        height: slideHeight\n      });\n      applyStyle(Slide.slide, {\n        width: options.autoWidth ? null : unit(Layout.slideWidth(Slide.index)),\n        height: Slide.container ? null : slideHeight\n      });\n    });\n    Splide.emit('resized');\n  }\n\n  return Layout;\n});\n;// CONCATENATED MODULE: ./src/js/components/drag/index.js\n/**\r\n * The component for supporting mouse drag and swipe.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\nvar drag_abs = Math.abs;\n/**\r\n * If the absolute velocity is greater thant this value,\r\n * a slider always goes to a different slide after drag, not allowed to stay on a current slide.\r\n */\n\nvar MIN_VELOCITY = 0.1;\n/**\r\n * Adjust how much the track can be pulled on the first or last page.\r\n * The larger number this is, the farther the track moves.\r\n * This should be around 5 - 9.\r\n *\r\n * @type {number}\r\n */\n\nvar FRICTION_REDUCER = 7;\n/**\r\n * The component supporting mouse drag and swipe.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const drag = (function (Splide, Components) {\n  /**\r\n   * Store the Move component.\r\n   *\r\n   * @type {Object}\r\n   */\n  var Track = Components.Track;\n  /**\r\n   * Store the Controller component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Controller = Components.Controller;\n  /**\r\n   * Coordinate of the track on starting drag.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var startCoord;\n  /**\r\n   * Analyzed info on starting drag.\r\n   *\r\n   * @type {Object|null}\r\n   */\n\n  var startInfo;\n  /**\r\n   * Analyzed info being updated while dragging/swiping.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var currentInfo;\n  /**\r\n   * Determine whether slides are being dragged or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isDragging;\n  /**\r\n   * Whether the slider direction is vertical or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isVertical = Splide.options.direction === TTB;\n  /**\r\n   * Axis for the direction.\r\n   *\r\n   * @type {string}\r\n   */\n\n  var axis = isVertical ? 'y' : 'x';\n  /**\r\n   * Drag component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Drag = {\n    /**\r\n     * Whether dragging is disabled or not.\r\n     *\r\n     * @type {boolean}\r\n     */\n    disabled: false,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      var _this = this;\n\n      var Elements = Components.Elements;\n      var track = Elements.track;\n      Splide.on('touchstart mousedown', start, track).on('touchmove mousemove', move, track, {\n        passive: false\n      }).on('touchend touchcancel mouseleave mouseup dragend', end, track).on('mounted refresh', function () {\n        // Prevent dragging an image or anchor itself.\n        each(Elements.list.querySelectorAll('img, a'), function (elm) {\n          Splide.off('dragstart', elm).on('dragstart', function (e) {\n            e.preventDefault();\n          }, elm, {\n            passive: false\n          });\n        });\n      }).on('mounted updated', function () {\n        _this.disabled = !Splide.options.drag;\n      });\n    }\n  };\n  /**\r\n   * Called when the track starts to be dragged.\r\n   *\r\n   * @param {TouchEvent|MouseEvent} e - TouchEvent or MouseEvent object.\r\n   */\n\n  function start(e) {\n    if (!Drag.disabled && !isDragging) {\n      // These prams are used to evaluate whether the slider should start moving.\n      init(e);\n    }\n  }\n  /**\r\n   * Initialize parameters.\r\n   *\r\n   * @param {TouchEvent|MouseEvent} e - TouchEvent or MouseEvent object.\r\n   */\n\n\n  function init(e) {\n    startCoord = Track.toCoord(Track.position);\n    startInfo = analyze(e, {});\n    currentInfo = startInfo;\n  }\n  /**\r\n   * Called while the track being dragged.\r\n   *\r\n   * @param {TouchEvent|MouseEvent} e - TouchEvent or MouseEvent object.\r\n   */\n\n\n  function move(e) {\n    if (startInfo) {\n      currentInfo = analyze(e, startInfo);\n\n      if (isDragging) {\n        if (e.cancelable) {\n          e.preventDefault();\n        }\n\n        if (!Splide.is(FADE)) {\n          var position = startCoord[axis] + currentInfo.offset[axis];\n          Track.translate(resist(position));\n        }\n      } else {\n        if (shouldMove(currentInfo)) {\n          Splide.emit('drag', startInfo);\n          isDragging = true;\n          Track.cancel(); // These params are actual drag data.\n\n          init(e);\n        }\n      }\n    }\n  }\n  /**\r\n   * Determine whether to start moving the track or not by drag angle.\r\n   *\r\n   * @param {Object} info - An information object.\r\n   *\r\n   * @return {boolean} - True if the track should be moved or false if not.\r\n   */\n\n\n  function shouldMove(_ref) {\n    var offset = _ref.offset;\n\n    if (Splide.State.is(MOVING) && Splide.options.waitForTransition) {\n      return false;\n    }\n\n    var angle = Math.atan(drag_abs(offset.y) / drag_abs(offset.x)) * 180 / Math.PI;\n\n    if (isVertical) {\n      angle = 90 - angle;\n    }\n\n    return angle < Splide.options.dragAngleThreshold;\n  }\n  /**\r\n   * Resist dragging the track on the first/last page because there is no more.\r\n   *\r\n   * @param {number} position - A position being applied to the track.\r\n   *\r\n   * @return {Object} - Adjusted position.\r\n   */\n\n\n  function resist(position) {\n    if (Splide.is(SLIDE)) {\n      var sign = Track.sign;\n\n      var _start = sign * Track.trim(Track.toPosition(0));\n\n      var _end = sign * Track.trim(Track.toPosition(Controller.edgeIndex));\n\n      position *= sign;\n\n      if (position < _start) {\n        position = _start - FRICTION_REDUCER * Math.log(_start - position);\n      } else if (position > _end) {\n        position = _end + FRICTION_REDUCER * Math.log(position - _end);\n      }\n\n      position *= sign;\n    }\n\n    return position;\n  }\n  /**\r\n   * Called when dragging ends.\r\n   */\n\n\n  function end() {\n    startInfo = null;\n\n    if (isDragging) {\n      Splide.emit('dragged', currentInfo);\n      go(currentInfo);\n      isDragging = false;\n    }\n  }\n  /**\r\n   * Go to the slide determined by the analyzed data.\r\n   *\r\n   * @param {Object} info - An info object.\r\n   */\n\n\n  function go(info) {\n    var velocity = info.velocity[axis];\n    var absV = drag_abs(velocity);\n\n    if (absV > 0) {\n      var options = Splide.options;\n      var index = Splide.index;\n      var sign = velocity < 0 ? -1 : 1;\n      var destIndex = index;\n\n      if (!Splide.is(FADE)) {\n        var destination = Track.position;\n\n        if (absV > options.flickVelocityThreshold && drag_abs(info.offset[axis]) < options.swipeDistanceThreshold) {\n          destination += sign * Math.min(absV * options.flickPower, Components.Layout.size * (options.flickMaxPages || 1));\n        }\n\n        destIndex = Track.toIndex(destination);\n      }\n      /*\r\n       * Do not allow the track to go to a previous position if there is enough velocity.\r\n       * Always use the adjacent index for the fade mode.\r\n       */\n\n\n      if (destIndex === index && absV > MIN_VELOCITY) {\n        destIndex = index + sign * Track.sign;\n      }\n\n      if (Splide.is(SLIDE)) {\n        destIndex = between(destIndex, 0, Controller.edgeIndex);\n      }\n\n      Controller.go(destIndex, options.isNavigation);\n    }\n  }\n  /**\r\n   * Analyze the given event object and return important information for handling swipe behavior.\r\n   *\r\n   * @param {Event}   e          - Touch or Mouse event object.\r\n   * @param {Object}  startInfo  - Information analyzed on start for calculating difference from the current one.\r\n   *\r\n   * @return {Object} - An object containing analyzed information, such as offset, velocity, etc.\r\n   */\n\n\n  function analyze(e, startInfo) {\n    var timeStamp = e.timeStamp,\n        touches = e.touches;\n\n    var _ref2 = touches ? touches[0] : e,\n        clientX = _ref2.clientX,\n        clientY = _ref2.clientY;\n\n    var _ref3 = startInfo.to || {},\n        _ref3$x = _ref3.x,\n        fromX = _ref3$x === void 0 ? clientX : _ref3$x,\n        _ref3$y = _ref3.y,\n        fromY = _ref3$y === void 0 ? clientY : _ref3$y;\n\n    var startTime = startInfo.time || 0;\n    var offset = {\n      x: clientX - fromX,\n      y: clientY - fromY\n    };\n    var duration = timeStamp - startTime;\n    var velocity = {\n      x: offset.x / duration,\n      y: offset.y / duration\n    };\n    return {\n      to: {\n        x: clientX,\n        y: clientY\n      },\n      offset: offset,\n      time: timeStamp,\n      velocity: velocity\n    };\n  }\n\n  return Drag;\n});\n;// CONCATENATED MODULE: ./src/js/components/click/index.js\n/**\r\n * The component for handling a click event.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * The component for handling a click event.\r\n * Click should be disabled during drag/swipe.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n/* harmony default export */ const click = (function (Splide, Components) {\n  /**\r\n   * Whether click is disabled or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n  var disabled = false;\n  /**\r\n   * Click component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Click = {\n    /**\r\n     * Mount only when the drag is activated and the slide type is not \"fade\".\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: Splide.options.drag,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Splide.on('click', onClick, Components.Elements.track, {\n        capture: true\n      }).on('drag', function () {\n        disabled = true;\n      }).on('dragged', function () {\n        // Make sure the flag is released after the click event is fired.\n        setTimeout(function () {\n          disabled = false;\n        });\n      });\n    }\n  };\n  /**\r\n   * Called when a track element is clicked.\r\n   *\r\n   * @param {Event} e - A click event.\r\n   */\n\n  function onClick(e) {\n    if (disabled) {\n      e.preventDefault();\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n    }\n  }\n\n  return Click;\n});\n;// CONCATENATED MODULE: ./src/js/components/autoplay/index.js\n/**\r\n * The component for playing slides automatically.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * Set of pause flags.\r\n */\n\nvar PAUSE_FLAGS = {\n  HOVER: 1,\n  FOCUS: 2,\n  MANUAL: 3\n};\n/**\r\n * The component for playing slides automatically.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n * @param {string} name       - A component name as a lowercase string.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const autoplay = (function (Splide, Components, name) {\n  /**\r\n   * Store pause flags.\r\n   *\r\n   * @type {Array}\r\n   */\n  var flags = [];\n  /**\r\n   * Store an interval object.\r\n   *\r\n   * @type {Object};\r\n   */\n\n  var interval;\n  /**\r\n   * Keep the Elements component.\r\n   *\r\n   * @type {string}\r\n   */\n\n  var Elements = Components.Elements;\n  /**\r\n   * Autoplay component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Autoplay = {\n    /**\r\n     * Required only when the autoplay option is true.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: Splide.options.autoplay,\n\n    /**\r\n     * Called when the component is mounted.\r\n     * Note that autoplay starts only if there are slides over perPage number.\r\n     */\n    mount: function mount() {\n      var options = Splide.options;\n\n      if (Elements.slides.length > options.perPage) {\n        interval = createInterval(function () {\n          Splide.go('>');\n        }, options.interval, function (rate) {\n          Splide.emit(name + \":playing\", rate);\n\n          if (Elements.bar) {\n            applyStyle(Elements.bar, {\n              width: rate * 100 + \"%\"\n            });\n          }\n        });\n        bind();\n        this.play();\n      }\n    },\n\n    /**\r\n     * Start autoplay.\r\n     *\r\n     * @param {number} flag - A pause flag to be removed.\r\n     */\n    play: function play(flag) {\n      if (flag === void 0) {\n        flag = 0;\n      }\n\n      flags = flags.filter(function (f) {\n        return f !== flag;\n      });\n\n      if (!flags.length) {\n        Splide.emit(name + \":play\");\n        interval.play(Splide.options.resetProgress);\n      }\n    },\n\n    /**\r\n     * Pause autoplay.\r\n     * Note that Array.includes is not supported by IE.\r\n     *\r\n     * @param {number} flag - A pause flag to be added.\r\n     */\n    pause: function pause(flag) {\n      if (flag === void 0) {\n        flag = 0;\n      }\n\n      interval.pause();\n\n      if (flags.indexOf(flag) === -1) {\n        flags.push(flag);\n      }\n\n      if (flags.length === 1) {\n        Splide.emit(name + \":pause\");\n      }\n    }\n  };\n  /**\r\n   * Listen some events.\r\n   */\n\n  function bind() {\n    var options = Splide.options;\n    var sibling = Splide.sibling;\n    var elms = [Splide.root, sibling ? sibling.root : null];\n\n    if (options.pauseOnHover) {\n      switchOn(elms, 'mouseleave', PAUSE_FLAGS.HOVER, true);\n      switchOn(elms, 'mouseenter', PAUSE_FLAGS.HOVER, false);\n    }\n\n    if (options.pauseOnFocus) {\n      switchOn(elms, 'focusout', PAUSE_FLAGS.FOCUS, true);\n      switchOn(elms, 'focusin', PAUSE_FLAGS.FOCUS, false);\n    }\n\n    if (Elements.play) {\n      Splide.on('click', function () {\n        // Need to be removed a focus flag at first.\n        Autoplay.play(PAUSE_FLAGS.FOCUS);\n        Autoplay.play(PAUSE_FLAGS.MANUAL);\n      }, Elements.play);\n    }\n\n    if (Elements.pause) {\n      switchOn([Elements.pause], 'click', PAUSE_FLAGS.MANUAL, false);\n    }\n\n    Splide.on('move refresh', function () {\n      Autoplay.play();\n    }) // Rewind the timer.\n    .on('destroy', function () {\n      Autoplay.pause();\n    });\n  }\n  /**\r\n   * Play or pause on the given event.\r\n   *\r\n   * @param {Element[]} elms  - Elements.\r\n   * @param {string}    event - An event name or names.\r\n   * @param {number}    flag  - A pause flag defined on the top.\r\n   * @param {boolean}   play  - Determine whether to play or pause.\r\n   */\n\n\n  function switchOn(elms, event, flag, play) {\n    elms.forEach(function (elm) {\n      Splide.on(event, function () {\n        Autoplay[play ? 'play' : 'pause'](flag);\n      }, elm);\n    });\n  }\n\n  return Autoplay;\n});\n;// CONCATENATED MODULE: ./src/js/components/cover/index.js\n/**\r\n * The component for change an img element to background image of its wrapper.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * The component for change an img element to background image of its wrapper.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const cover = (function (Splide, Components) {\n  /**\r\n   * Hold options.\r\n   *\r\n   * @type {Object}\r\n   */\n  var options = Splide.options;\n  /**\r\n   * Cover component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Cover = {\n    /**\r\n     * Required only when \"cover\" option is true.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: options.cover,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Splide.on('lazyload:loaded', function (img) {\n        cover(img, false);\n      });\n      Splide.on('mounted updated refresh', function () {\n        return apply(false);\n      });\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      apply(true);\n    }\n  };\n  /**\r\n   * Apply \"cover\" to all slides.\r\n   *\r\n   * @param {boolean} uncover - If true, \"cover\" will be clear.\r\n   */\n\n  function apply(uncover) {\n    Components.Elements.each(function (Slide) {\n      var img = child(Slide.slide, 'IMG') || child(Slide.container, 'IMG');\n\n      if (img && img.src) {\n        cover(img, uncover);\n      }\n    });\n  }\n  /**\r\n   * Set background image of the parent element, using source of the given image element.\r\n   *\r\n   * @param {Element} img     - An image element.\r\n   * @param {boolean} uncover - Reset \"cover\".\r\n   */\n\n\n  function cover(img, uncover) {\n    applyStyle(img.parentElement, {\n      background: uncover ? '' : \"center/cover no-repeat url(\\\"\" + img.src + \"\\\")\"\n    });\n    applyStyle(img, {\n      display: uncover ? '' : 'none'\n    });\n  }\n\n  return Cover;\n});\n;// CONCATENATED MODULE: ./src/js/components/arrows/path.js\n/**\r\n * Export vector path for an arrow.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Namespace definition for SVG element.\r\n *\r\n * @type {string}\r\n */\nvar XML_NAME_SPACE = 'http://www.w3.org/2000/svg';\n/**\r\n * The arrow vector path.\r\n *\r\n * @type {number}\r\n */\n\nvar PATH = 'm15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z';\n/**\r\n * SVG width and height.\r\n *\r\n * @type {number}\r\n */\n\nvar SIZE = 40;\n;// CONCATENATED MODULE: ./src/js/components/arrows/index.js\n/**\r\n * The component for appending prev/next arrows.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The component for appending prev/next arrows.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n * @param {string} name       - A component name as a lowercase string.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const arrows = (function (Splide, Components, name) {\n  /**\r\n   * Previous arrow element.\r\n   *\r\n   * @type {Element|undefined}\r\n   */\n  var prev;\n  /**\r\n   * Next arrow element.\r\n   *\r\n   * @type {Element|undefined}\r\n   */\n\n  var next;\n  /**\r\n   * Store the class list.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var classes = Splide.classes;\n  /**\r\n   * Hold the root element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var root = Splide.root;\n  /**\r\n   * Whether arrows are created programmatically or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var created;\n  /**\r\n   * Hold the Elements component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Elements = Components.Elements;\n  /**\r\n   * Arrows component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Arrows = {\n    /**\r\n     * Required when the arrows option is true.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: Splide.options.arrows,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      // Attempt to get arrows from HTML source.\n      prev = Elements.arrows.prev;\n      next = Elements.arrows.next; // If arrows were not found in HTML, let's generate them.\n\n      if ((!prev || !next) && Splide.options.arrows) {\n        prev = createArrow(true);\n        next = createArrow(false);\n        created = true;\n        appendArrows();\n      }\n\n      if (prev && next) {\n        bind();\n      }\n\n      this.arrows = {\n        prev: prev,\n        next: next\n      };\n    },\n\n    /**\r\n     * Called after all components are mounted.\r\n     */\n    mounted: function mounted() {\n      Splide.emit(name + \":mounted\", prev, next);\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      removeAttribute([prev, next], 'disabled');\n\n      if (created) {\n        dom_remove(prev.parentElement);\n      }\n    }\n  };\n  /**\r\n   * Listen to native and custom events.\r\n   */\n\n  function bind() {\n    Splide.on('click', function () {\n      Splide.go('<');\n    }, prev).on('click', function () {\n      Splide.go('>');\n    }, next).on('mounted move updated refresh', updateDisabled);\n  }\n  /**\r\n   * Update a disabled attribute.\r\n   */\n\n\n  function updateDisabled() {\n    var _Components$Controlle = Components.Controller,\n        prevIndex = _Components$Controlle.prevIndex,\n        nextIndex = _Components$Controlle.nextIndex;\n    var isEnough = Splide.length > Splide.options.perPage || Splide.is(LOOP);\n    prev.disabled = prevIndex < 0 || !isEnough;\n    next.disabled = nextIndex < 0 || !isEnough;\n    Splide.emit(name + \":updated\", prev, next, prevIndex, nextIndex);\n  }\n  /**\r\n   * Create a wrapper element and append arrows.\r\n   */\n\n\n  function appendArrows() {\n    var wrapper = create('div', {\n      \"class\": classes.arrows\n    });\n    append(wrapper, prev);\n    append(wrapper, next);\n    var slider = Elements.slider;\n    var parent = Splide.options.arrows === 'slider' && slider ? slider : root;\n    before(wrapper, parent.firstElementChild);\n  }\n  /**\r\n   * Create an arrow element.\r\n   *\r\n   * @param {boolean} prev - Determine to create a prev arrow or next arrow.\r\n   *\r\n   * @return {Element} - A created arrow element.\r\n   */\n\n\n  function createArrow(prev) {\n    var arrow = \"<button class=\\\"\" + classes.arrow + \" \" + (prev ? classes.prev : classes.next) + \"\\\" type=\\\"button\\\">\" + (\"<svg xmlns=\\\"\" + XML_NAME_SPACE + \"\\\"\\tviewBox=\\\"0 0 \" + SIZE + \" \" + SIZE + \"\\\"\\twidth=\\\"\" + SIZE + \"\\\"\\theight=\\\"\" + SIZE + \"\\\">\") + (\"<path d=\\\"\" + (Splide.options.arrowPath || PATH) + \"\\\" />\");\n    return domify(arrow);\n  }\n\n  return Arrows;\n});\n;// CONCATENATED MODULE: ./src/js/components/pagination/index.js\n/**\r\n * The component for handling pagination\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * The event name for updating some attributes of pagination nodes.\r\n *\r\n * @type {string}\r\n */\n\nvar ATTRIBUTES_UPDATE_EVENT = 'move.page';\n/**\r\n * The event name for recreating pagination.\r\n *\r\n * @type {string}\r\n */\n\nvar UPDATE_EVENT = 'updated.page refresh.page';\n/**\r\n * The component for handling pagination\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n * @param {string} name       - A component name as a lowercase string.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const pagination = (function (Splide, Components, name) {\n  /**\r\n   * Store all data for pagination.\r\n   * - list: A list element.\r\n   * - items: An array that contains objects(li, button, index, page).\r\n   *\r\n   * @type {Object}\r\n   */\n  var data = {};\n  /**\r\n   * Hold the Elements component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Elements = Components.Elements;\n  /**\r\n   * Pagination component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Pagination = {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      var pagination = Splide.options.pagination;\n\n      if (pagination) {\n        data = createPagination();\n        var slider = Elements.slider;\n        var parent = pagination === 'slider' && slider ? slider : Splide.root;\n        append(parent, data.list);\n        Splide.on(ATTRIBUTES_UPDATE_EVENT, updateAttributes);\n      }\n\n      Splide.off(UPDATE_EVENT).on(UPDATE_EVENT, function () {\n        Pagination.destroy();\n\n        if (Splide.options.pagination) {\n          Pagination.mount();\n          Pagination.mounted();\n        }\n      });\n    },\n\n    /**\r\n     * Called after all components are mounted.\r\n     */\n    mounted: function mounted() {\n      if (Splide.options.pagination) {\n        var index = Splide.index;\n        Splide.emit(name + \":mounted\", data, this.getItem(index));\n        updateAttributes(index, -1);\n      }\n    },\n\n    /**\r\n     * Destroy the pagination.\r\n     * Be aware that node.remove() is not supported by IE.\r\n     */\n    destroy: function destroy() {\n      dom_remove(data.list);\n\n      if (data.items) {\n        data.items.forEach(function (item) {\n          Splide.off('click', item.button);\n        });\n      } // Do not remove UPDATE_EVENT to recreate pagination if needed.\n\n\n      Splide.off(ATTRIBUTES_UPDATE_EVENT);\n      data = {};\n    },\n\n    /**\r\n     * Return an item by index.\r\n     *\r\n     * @param {number} index - A slide index.\r\n     *\r\n     * @return {Object|undefined} - An item object on success or undefined on failure.\r\n     */\n    getItem: function getItem(index) {\n      return data.items[Components.Controller.toPage(index)];\n    },\n\n    /**\r\n     * Return object containing pagination data.\r\n     *\r\n     * @return {Object} - Pagination data including list and items.\r\n     */\n    get data() {\n      return data;\n    }\n\n  };\n  /**\r\n   * Update attributes.\r\n   *\r\n   * @param {number} index     - Active index.\r\n   * @param {number} prevIndex - Prev index.\r\n   */\n\n  function updateAttributes(index, prevIndex) {\n    var prev = Pagination.getItem(prevIndex);\n    var curr = Pagination.getItem(index);\n    var active = STATUS_CLASSES.active;\n\n    if (prev) {\n      removeClass(prev.button, active);\n    }\n\n    if (curr) {\n      addClass(curr.button, active);\n    }\n\n    Splide.emit(name + \":updated\", data, prev, curr);\n  }\n  /**\r\n   * Create a wrapper and button elements.\r\n   *\r\n   * @return {Object} - An object contains all data.\r\n   */\n\n\n  function createPagination() {\n    var options = Splide.options;\n    var classes = Splide.classes;\n    var list = create('ul', {\n      \"class\": classes.pagination\n    });\n    var items = Elements.getSlides(false).filter(function (Slide) {\n      return options.focus !== false || Slide.index % options.perPage === 0;\n    }).map(function (Slide, page) {\n      var li = create('li', {});\n      var button = create('button', {\n        \"class\": classes.page,\n        type: 'button'\n      });\n      append(li, button);\n      append(list, li);\n      Splide.on('click', function () {\n        Splide.go(\">\" + page);\n      }, button);\n      return {\n        li: li,\n        button: button,\n        page: page,\n        Slides: Elements.getSlidesByPage(page)\n      };\n    });\n    return {\n      list: list,\n      items: items\n    };\n  }\n\n  return Pagination;\n});\n;// CONCATENATED MODULE: ./src/js/components/lazyload/index.js\n/**\r\n * The component for loading slider images lazily.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The name for a data attribute of src.\r\n *\r\n * @type {string}\r\n */\n\nvar SRC_DATA_NAME = 'data-splide-lazy';\n/**\r\n * The name for a data attribute of srcset.\r\n *\r\n * @type {string}\r\n */\n\nvar SRCSET_DATA_NAME = 'data-splide-lazy-srcset';\n/**\r\n * The component for loading slider images lazily.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n * @param {string} name       - A component name as a lowercase string.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const lazyload = (function (Splide, Components, name) {\n  /**\r\n   * Next index for sequential loading.\r\n   *\r\n   * @type {number}\r\n   */\n  var nextIndex;\n  /**\r\n   * Store objects containing an img element and a Slide object.\r\n   *\r\n   * @type {Object[]}\r\n   */\n\n  var images;\n  /**\r\n   * Store the options.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var options = Splide.options;\n  /**\r\n   * Whether to load images sequentially or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isSequential = options.lazyLoad === 'sequential';\n  /**\r\n   * Lazyload component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Lazyload = {\n    /**\r\n     * Mount only when the lazyload option is provided.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: options.lazyLoad,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Splide.on('mounted refresh', function () {\n        init();\n        Components.Elements.each(function (Slide) {\n          each(Slide.slide.querySelectorAll(\"[\" + SRC_DATA_NAME + \"], [\" + SRCSET_DATA_NAME + \"]\"), function (img) {\n            if (!img.src && !img.srcset) {\n              images.push({\n                img: img,\n                Slide: Slide\n              });\n              applyStyle(img, {\n                display: 'none'\n              });\n            }\n          });\n        });\n\n        if (isSequential) {\n          loadNext();\n        }\n      });\n\n      if (!isSequential) {\n        Splide.on(\"mounted refresh moved.\" + name, check);\n      }\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: init\n  };\n  /**\r\n   * Initialize parameters.\r\n   */\n\n  function init() {\n    images = [];\n    nextIndex = 0;\n  }\n  /**\r\n   * Check how close each image is from the active slide and\r\n   * determine whether to start loading or not, according to the distance.\r\n   *\r\n   * @param {number} index - Current index.\r\n   */\n\n\n  function check(index) {\n    index = isNaN(index) ? Splide.index : index;\n    images = images.filter(function (image) {\n      if (image.Slide.isWithin(index, options.perPage * (options.preloadPages + 1))) {\n        load(image.img, image.Slide);\n        return false;\n      }\n\n      return true;\n    }); // Unbind if all images are loaded.\n\n    if (!images[0]) {\n      Splide.off(\"moved.\" + name);\n    }\n  }\n  /**\r\n   * Start loading an image.\r\n   * Creating a clone of the image element since setting src attribute directly to it\r\n   * often occurs 'hitch', blocking some other processes of a browser.\r\n   *\r\n   * @param {Element} img   - An image element.\r\n   * @param {Object}  Slide - A Slide object.\r\n   */\n\n\n  function load(img, Slide) {\n    addClass(Slide.slide, STATUS_CLASSES.loading);\n    var spinner = create('span', {\n      \"class\": Splide.classes.spinner\n    });\n    append(img.parentElement, spinner);\n\n    img.onload = function () {\n      loaded(img, spinner, Slide, false);\n    };\n\n    img.onerror = function () {\n      loaded(img, spinner, Slide, true);\n    };\n\n    setAttribute(img, 'srcset', getAttribute(img, SRCSET_DATA_NAME) || '');\n    setAttribute(img, 'src', getAttribute(img, SRC_DATA_NAME) || '');\n  }\n  /**\r\n   * Start loading a next image in images array.\r\n   */\n\n\n  function loadNext() {\n    if (nextIndex < images.length) {\n      var image = images[nextIndex];\n      load(image.img, image.Slide);\n    }\n\n    nextIndex++;\n  }\n  /**\r\n   * Called just after the image was loaded or loading was aborted by some error.\r\n   *\r\n   * @param {Element} img     - An image element.\r\n   * @param {Element} spinner - A spinner element.\r\n   * @param {Object}  Slide   - A Slide object.\r\n   * @param {boolean} error   - True if the image was loaded successfully or false on error.\r\n   */\n\n\n  function loaded(img, spinner, Slide, error) {\n    removeClass(Slide.slide, STATUS_CLASSES.loading);\n\n    if (!error) {\n      dom_remove(spinner);\n      applyStyle(img, {\n        display: ''\n      });\n      Splide.emit(name + \":loaded\", img).emit('resize');\n    }\n\n    if (isSequential) {\n      loadNext();\n    }\n  }\n\n  return Lazyload;\n});\n;// CONCATENATED MODULE: ./src/js/constants/a11y.js\n/**\r\n * Export aria attribute names.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Attribute name for aria-current.\r\n *\r\n * @type {string}\r\n */\nvar ARIA_CURRENRT = 'aria-current';\n/**\r\n * Attribute name for aria-control.\r\n *\r\n * @type {string}\r\n */\n\nvar ARIA_CONTROLS = 'aria-controls';\n/**\r\n * Attribute name for aria-control.\r\n *\r\n * @type {string}\r\n */\n\nvar ARIA_LABEL = 'aria-label';\n/**\r\n * Attribute name for aria-labelledby.\r\n *\r\n * @type {string}\r\n */\n\nvar ARIA_LABELLEDBY = 'aria-labelledby';\n/**\r\n * Attribute name for aria-hidden.\r\n *\r\n * @type {string}\r\n */\n\nvar ARIA_HIDDEN = 'aria-hidden';\n/**\r\n * Attribute name for tab-index.\r\n *\r\n * @type {string}\r\n */\n\nvar TAB_INDEX = 'tabindex';\n;// CONCATENATED MODULE: ./src/js/components/keyboard/index.js\n/**\r\n * The component for controlling slides via keyboard.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * Map a key to a slide control.\r\n *\r\n * @type {Object}\r\n */\n\nvar KEY_MAP = {\n  ltr: {\n    ArrowLeft: '<',\n    ArrowRight: '>',\n    // For IE.\n    Left: '<',\n    Right: '>'\n  },\n  rtl: {\n    ArrowLeft: '>',\n    ArrowRight: '<',\n    // For IE.\n    Left: '>',\n    Right: '<'\n  },\n  ttb: {\n    ArrowUp: '<',\n    ArrowDown: '>',\n    // For IE.\n    Up: '<',\n    Down: '>'\n  }\n};\n/**\r\n * The component for controlling slides via keyboard.\r\n *\r\n * @param {Splide} Splide - A Splide instance.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const keyboard = (function (Splide) {\n  /**\r\n   * Hold the target element.\r\n   *\r\n   * @type {Element|Document|undefined}\r\n   */\n  var target;\n  return {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Splide.on('mounted updated', function () {\n        var options = Splide.options;\n        var root = Splide.root;\n        var map = KEY_MAP[options.direction];\n        var keyboard = options.keyboard;\n\n        if (target) {\n          Splide.off('keydown', target);\n          removeAttribute(root, TAB_INDEX);\n        }\n\n        if (keyboard) {\n          if (keyboard === 'focused') {\n            target = root;\n            setAttribute(root, TAB_INDEX, 0);\n          } else {\n            target = document;\n          }\n\n          Splide.on('keydown', function (e) {\n            if (map[e.key]) {\n              Splide.go(map[e.key]);\n            }\n          }, target);\n        }\n      });\n    }\n  };\n});\n;// CONCATENATED MODULE: ./src/js/components/a11y/index.js\n/**\r\n * The component for enhancing accessibility.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The component for enhancing accessibility.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const a11y = (function (Splide, Components) {\n  /**\r\n   * Hold a i18n object.\r\n   *\r\n   * @type {Object}\r\n   */\n  var i18n = Splide.i18n;\n  /**\r\n   * Hold the Elements component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Elements = Components.Elements;\n  /**\r\n   * All attributes related with A11y.\r\n   *\r\n   * @type {string[]}\r\n   */\n\n  var allAttributes = [ARIA_HIDDEN, TAB_INDEX, ARIA_CONTROLS, ARIA_LABEL, ARIA_CURRENRT, 'role'];\n  /**\r\n   * A11y component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var A11y = {\n    /**\r\n     * Required only when the accessibility option is true.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: Splide.options.accessibility,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Splide.on('visible', function (Slide) {\n        updateSlide(Slide.slide, true);\n      }).on('hidden', function (Slide) {\n        updateSlide(Slide.slide, false);\n      }).on('arrows:mounted', initArrows).on('arrows:updated', updateArrows).on('pagination:mounted', initPagination).on('pagination:updated', updatePagination).on('refresh', function () {\n        removeAttribute(Components.Clones.clones, allAttributes);\n      });\n\n      if (Splide.options.isNavigation) {\n        Splide.on('navigation:mounted navigation:updated', initNavigation).on('active', function (Slide) {\n          updateNavigation(Slide, true);\n        }).on('inactive', function (Slide) {\n          updateNavigation(Slide, false);\n        });\n      }\n\n      initAutoplay();\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      var Arrows = Components.Arrows;\n      var arrows = Arrows ? Arrows.arrows : {};\n      removeAttribute(Elements.slides.concat([arrows.prev, arrows.next, Elements.play, Elements.pause]), allAttributes);\n    }\n  };\n  /**\r\n   * Update slide attributes when it gets visible or hidden.\r\n   *\r\n   * @param {Element} slide   - A slide element.\r\n   * @param {Boolean} visible - True when the slide gets visible, or false when hidden.\r\n   */\n\n  function updateSlide(slide, visible) {\n    setAttribute(slide, ARIA_HIDDEN, !visible);\n\n    if (Splide.options.slideFocus) {\n      setAttribute(slide, TAB_INDEX, visible ? 0 : -1);\n    }\n  }\n  /**\r\n   * Initialize arrows if they are available.\r\n   * Append screen reader elements and add aria-controls attribute.\r\n   *\r\n   * @param {Element} prev - Previous arrow element.\r\n   * @param {Element} next - Next arrow element.\r\n   */\n\n\n  function initArrows(prev, next) {\n    var controls = Elements.track.id;\n    setAttribute(prev, ARIA_CONTROLS, controls);\n    setAttribute(next, ARIA_CONTROLS, controls);\n  }\n  /**\r\n   * Update arrow attributes.\r\n   *\r\n   * @param {Element} prev      - Previous arrow element.\r\n   * @param {Element} next      - Next arrow element.\r\n   * @param {number}  prevIndex - Previous slide index or -1 when there is no precede slide.\r\n   * @param {number}  nextIndex - Next slide index or -1 when there is no next slide.\r\n   */\n\n\n  function updateArrows(prev, next, prevIndex, nextIndex) {\n    var index = Splide.index;\n    var prevLabel = prevIndex > -1 && index < prevIndex ? i18n.last : i18n.prev;\n    var nextLabel = nextIndex > -1 && index > nextIndex ? i18n.first : i18n.next;\n    setAttribute(prev, ARIA_LABEL, prevLabel);\n    setAttribute(next, ARIA_LABEL, nextLabel);\n  }\n  /**\r\n   * Initialize pagination if it's available.\r\n   * Append a screen reader element and add aria-controls/label attribute to each item.\r\n   *\r\n   * @param {Object} data       - Data object containing all items.\r\n   * @param {Object} activeItem - An initial active item.\r\n   */\n\n\n  function initPagination(data, activeItem) {\n    if (activeItem) {\n      setAttribute(activeItem.button, ARIA_CURRENRT, true);\n    }\n\n    data.items.forEach(function (item) {\n      var options = Splide.options;\n      var text = options.focus === false && options.perPage > 1 ? i18n.pageX : i18n.slideX;\n      var label = sprintf(text, item.page + 1);\n      var button = item.button;\n      var controls = item.Slides.map(function (Slide) {\n        return Slide.slide.id;\n      });\n      setAttribute(button, ARIA_CONTROLS, controls.join(' '));\n      setAttribute(button, ARIA_LABEL, label);\n    });\n  }\n  /**\r\n   * Update pagination attributes.\r\n   *\r\n   * @param {Object}  data - Data object containing all items.\r\n   * @param {Element} prev - A previous active element.\r\n   * @param {Element} curr - A current active element.\r\n   */\n\n\n  function updatePagination(data, prev, curr) {\n    if (prev) {\n      removeAttribute(prev.button, ARIA_CURRENRT);\n    }\n\n    if (curr) {\n      setAttribute(curr.button, ARIA_CURRENRT, true);\n    }\n  }\n  /**\r\n   * Initialize autoplay buttons.\r\n   */\n\n\n  function initAutoplay() {\n    ['play', 'pause'].forEach(function (name) {\n      var elm = Elements[name];\n\n      if (elm) {\n        if (!isButton(elm)) {\n          setAttribute(elm, 'role', 'button');\n        }\n\n        setAttribute(elm, ARIA_CONTROLS, Elements.track.id);\n        setAttribute(elm, ARIA_LABEL, i18n[name]);\n      }\n    });\n  }\n  /**\r\n   * Initialize navigation slider.\r\n   * Add button role, aria-label, aria-controls to slide elements and append screen reader text to them.\r\n   *\r\n   * @param {Splide} main - A main Splide instance.\r\n   */\n\n\n  function initNavigation(main) {\n    Elements.each(function (Slide) {\n      var slide = Slide.slide;\n      var realIndex = Slide.realIndex;\n\n      if (!isButton(slide)) {\n        setAttribute(slide, 'role', 'button');\n      }\n\n      var slideIndex = realIndex > -1 ? realIndex : Slide.index;\n      var label = sprintf(i18n.slideX, slideIndex + 1);\n      var mainSlide = main.Components.Elements.getSlide(slideIndex);\n      setAttribute(slide, ARIA_LABEL, label);\n\n      if (mainSlide) {\n        setAttribute(slide, ARIA_CONTROLS, mainSlide.slide.id);\n      }\n    });\n  }\n  /**\r\n   * Update navigation attributes.\r\n   *\r\n   * @param {Object}  Slide  - A target Slide object.\r\n   * @param {boolean} active - True if the slide is active or false if inactive.\r\n   */\n\n\n  function updateNavigation(_ref, active) {\n    var slide = _ref.slide;\n\n    if (active) {\n      setAttribute(slide, ARIA_CURRENRT, true);\n    } else {\n      removeAttribute(slide, ARIA_CURRENRT);\n    }\n  }\n  /**\r\n   * Check if the given element is button or not.\r\n   *\r\n   * @param {Element} elm - An element to be checked.\r\n   *\r\n   * @return {boolean} - True if the given element is button.\r\n   */\n\n\n  function isButton(elm) {\n    return elm.tagName === 'BUTTON';\n  }\n\n  return A11y;\n});\n;// CONCATENATED MODULE: ./src/js/components/sync/index.js\n/**\r\n * The component for synchronizing a slider with another.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * The event name for sync.\r\n *\r\n * @type {string}\r\n */\n\nvar SYNC_EVENT = 'move.sync';\n/**\r\n * The event names for click navigation.\r\n * @type {string}\r\n */\n\nvar CLICK_EVENTS = 'mouseup touchend';\n/**\r\n * The keys for triggering the navigation button.\r\n *\r\n * @type {String[]}\r\n */\n\nvar TRIGGER_KEYS = [' ', 'Enter', 'Spacebar'];\n/**\r\n * The component for synchronizing a slider with another.\r\n *\r\n * @param {Splide} Splide - A Splide instance.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const sync = (function (Splide) {\n  /**\r\n   * Keep the sibling Splide instance.\r\n   *\r\n   * @type {Splide}\r\n   */\n  var sibling = Splide.sibling;\n  /**\r\n   * Whether the sibling slider is navigation or not.\r\n   *\r\n   * @type {Splide|boolean}\r\n   */\n\n  var isNavigation = sibling && sibling.options.isNavigation;\n  /**\r\n   * Layout component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Sync = {\n    /**\r\n     * Required only when the sub slider is available.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: !!sibling,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      syncMain();\n      syncSibling();\n\n      if (isNavigation) {\n        bind();\n        Splide.on('refresh', function () {\n          setTimeout(function () {\n            bind();\n            sibling.emit('navigation:updated', Splide);\n          });\n        });\n      }\n    },\n\n    /**\r\n     * Called after all components are mounted.\r\n     */\n    mounted: function mounted() {\n      if (isNavigation) {\n        sibling.emit('navigation:mounted', Splide);\n      }\n    }\n  };\n  /**\r\n   * Listen the primary slider event to move secondary one.\r\n   * Must unbind a handler at first to avoid infinite loop.\r\n   */\n\n  function syncMain() {\n    Splide.on(SYNC_EVENT, function (newIndex, prevIndex, destIndex) {\n      sibling.off(SYNC_EVENT).go(sibling.is(LOOP) ? destIndex : newIndex, false);\n      syncSibling();\n    });\n  }\n  /**\r\n   * Listen the secondary slider event to move primary one.\r\n   * Must unbind a handler at first to avoid infinite loop.\r\n   */\n\n\n  function syncSibling() {\n    sibling.on(SYNC_EVENT, function (newIndex, prevIndex, destIndex) {\n      Splide.off(SYNC_EVENT).go(Splide.is(LOOP) ? destIndex : newIndex, false);\n      syncMain();\n    });\n  }\n  /**\r\n   * Listen some events on each slide.\r\n   */\n\n\n  function bind() {\n    sibling.Components.Elements.each(function (_ref) {\n      var slide = _ref.slide,\n          index = _ref.index;\n\n      /*\r\n       * Listen mouseup and touchend events to handle click.\r\n       */\n      Splide.off(CLICK_EVENTS, slide).on(CLICK_EVENTS, function (e) {\n        // Ignore a middle or right click.\n        if (!e.button || e.button === 0) {\n          moveSibling(index);\n        }\n      }, slide);\n      /*\r\n       * Subscribe keyup to handle Enter and Space key.\r\n       * Note that Array.includes is not supported by IE.\r\n       */\n\n      Splide.off('keyup', slide).on('keyup', function (e) {\n        if (TRIGGER_KEYS.indexOf(e.key) > -1) {\n          e.preventDefault();\n          moveSibling(index);\n        }\n      }, slide, {\n        passive: false\n      });\n    });\n  }\n  /**\r\n   * Move the sibling to the given index.\r\n   * Need to check \"IDLE\" status because slides can be moving by Drag component.\r\n   *\r\n   * @param {number} index - Target index.\r\n   */\n\n\n  function moveSibling(index) {\n    if (Splide.State.is(IDLE)) {\n      sibling.go(index);\n    }\n  }\n\n  return Sync;\n});\n;// CONCATENATED MODULE: ./src/js/components/breakpoints/index.js\n/**\r\n * The component for updating options according to a current window width.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * Interval time for throttle.\r\n *\r\n * @type {number}\r\n */\n\nvar THROTTLE = 50;\n/**\r\n * The component for updating options according to a current window width.\r\n *\r\n * @param {Splide} Splide - A Splide instance.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const breakpoints = (function (Splide) {\n  /**\r\n   * Store breakpoints.\r\n   *\r\n   * @type {Object|boolean}\r\n   */\n  var breakpoints = Splide.options.breakpoints;\n  /**\r\n   * The check function whose frequency of call is reduced.\r\n   *\r\n   * @type {Function}\r\n   */\n\n  var throttledCheck = throttle(check, THROTTLE);\n  /**\r\n   * Keep initial options.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var initialOptions;\n  /**\r\n   * An array containing objects of point and MediaQueryList.\r\n   *\r\n   * @type {Object[]}\r\n   */\n\n  var map = [];\n  /**\r\n   * Hold the previous breakpoint.\r\n   *\r\n   * @type {number|undefined}\r\n   */\n\n  var prevPoint;\n  /**\r\n   * Breakpoints component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Breakpoints = {\n    /**\r\n     * Required only when the breakpoints definition is provided and browser supports matchMedia.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: breakpoints && matchMedia,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      map = Object.keys(breakpoints).sort(function (n, m) {\n        return +n - +m;\n      }).map(function (point) {\n        return {\n          point: point,\n          mql: matchMedia(\"(max-width:\" + point + \"px)\")\n        };\n      });\n      /*\r\n       * To keep monitoring resize event after destruction without \"completely\",\r\n       * use native addEventListener instead of Splide.on.\r\n       */\n\n      this.destroy(true);\n      addEventListener('resize', throttledCheck); // Keep initial options to apply them when no breakpoint matches.\n\n      initialOptions = Splide.options;\n      check();\n    },\n\n    /**\r\n     * Destroy.\r\n     *\r\n     * @param {boolean} completely - Whether to destroy Splide completely.\r\n     */\n    destroy: function destroy(completely) {\n      if (completely) {\n        removeEventListener('resize', throttledCheck);\n      }\n    }\n  };\n  /**\r\n   * Check the breakpoint.\r\n   */\n\n  function check() {\n    var point = getPoint();\n\n    if (point !== prevPoint) {\n      prevPoint = point;\n      var State = Splide.State;\n      var options = breakpoints[point] || initialOptions;\n      var destroy = options.destroy;\n\n      if (destroy) {\n        Splide.options = initialOptions;\n        Splide.destroy(destroy === 'completely');\n      } else {\n        if (State.is(DESTROYED)) {\n          Splide.mount();\n        }\n\n        Splide.options = options;\n      }\n    }\n  }\n  /**\r\n   * Return the breakpoint matching current window width.\r\n   * Note that Array.prototype.find is not supported by IE.\r\n   *\r\n   * @return {number|string} - A breakpoint as number or string. -1 if no point matches.\r\n   */\n\n\n  function getPoint() {\n    var item = map.filter(function (item) {\n      return item.mql.matches;\n    })[0];\n    return item ? item.point : -1;\n  }\n\n  return Breakpoints;\n});\n;// CONCATENATED MODULE: ./src/js/components/index.js\n/**\r\n * Export components.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar COMPLETE = {\n  Options: options,\n  Breakpoints: breakpoints,\n  Controller: controller,\n  Elements: components_elements,\n  Track: track,\n  Clones: clones,\n  Layout: layout,\n  Drag: drag,\n  Click: click,\n  Autoplay: autoplay,\n  Cover: cover,\n  Arrows: arrows,\n  Pagination: pagination,\n  LazyLoad: lazyload,\n  Keyboard: keyboard,\n  Sync: sync,\n  A11y: a11y\n};\nvar LIGHT = {\n  Options: options,\n  Controller: controller,\n  Elements: components_elements,\n  Track: track,\n  Clones: clones,\n  Layout: layout,\n  Drag: drag,\n  Click: click,\n  Arrows: arrows,\n  Pagination: pagination,\n  A11y: a11y\n};\n;// CONCATENATED MODULE: ./build/module/module.js\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/**\r\n * Export Splide class for import.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * Export Splide class for import from other projects.\r\n */\n\nvar module_Splide = /*#__PURE__*/function (_Core) {\n  _inheritsLoose(Splide, _Core);\n\n  function Splide(root, options) {\n    return _Core.call(this, root, options, COMPLETE) || this;\n  }\n\n  return Splide;\n}(Splide);\n\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(__webpack_module_cache__[moduleId]) {\n/******/ \t\t\treturn __webpack_module_cache__[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__webpack_require__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__webpack_require__.r = (exports) => {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/************************************************************************/\n/******/ \t// module exports must be returned from runtime so entry inlining is disabled\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(311);\n/******/ })()\n;\n});", "export default require(\"./node_modules/@splidejs/splide/dist/js/splide.esm.js\");"],
  "mappings": "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",
  "names": []
}
